<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Documentation policy: comment every function, conditional, and loop to describe its role. -->
  <meta charset="UTF-8">
  <title>Zelda II HTML5 Prototype</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      margin: 0 auto;
      background: #202048;
    }
    #info {
      text-align: center;
      margin-top: 8px;
      font-size: 14px;
    }
    #info kbd {
      padding: 1px 4px;
      border-radius: 3px;
      border: 1px solid #555;
      background: #222;
      font-family: monospace;
      font-size: 12px;
    }
    #touch-controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 24px;
      margin: 18px auto 32px;
      max-width: 520px;
      padding: 0 16px;
      user-select: none;
      touch-action: manipulation;
    }
    #touch-controls button {
      width: 64px;
      height: 64px;
      border-radius: 14px;
      border: 2px solid #555;
      background: #1d1d2e;
      color: #eee;
      font-size: 18px;
      font-weight: 600;
      text-transform: uppercase;
      box-shadow: inset 0 2px 0 rgba(255,255,255,0.05);
      transition: transform 0.1s ease, background 0.1s ease;
      user-select: none;
      -webkit-user-select: none;
    }
    #touch-controls button:active,
    #touch-controls button.active {
      background: #353562;
      transform: translateY(2px);
    }
    #touch-controls .dpad {
      display: grid;
      grid-template-columns: repeat(3, 64px);
      grid-template-rows: repeat(3, 64px);
      gap: 8px;
    }
    #touch-controls .dpad button {
      font-size: 20px;
    }
    #touch-controls .dpad button.empty {
      visibility: hidden;
      pointer-events: none;
    }
    #touch-controls .actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #touch-controls .actions button {
      width: 88px;
    }
    @media (max-width: 480px) {
      #touch-controls {
        gap: 16px;
      }
      #touch-controls button {
        width: 56px;
        height: 56px;
      }
      #touch-controls .dpad {
        grid-template-columns: repeat(3, 56px);
        grid-template-rows: repeat(3, 56px);
      }
      #touch-controls .actions button {
        width: 72px;
      }
    }
  </style>
</head>
<body>
<canvas id="game" width="512" height="288"></canvas>
<div id="info">
  Controls:
  <kbd>W</kbd>/<kbd>A</kbd>/<kbd>S</kbd>/<kbd>D</kbd> move &amp; crouch,
  <kbd>K</kbd> jump,
  <kbd>J</kbd> stab
</div>
<div id="touch-controls">
  <div class="dpad">
    <button class="empty" tabindex="-1" aria-hidden="true"></button>
    <button data-key="w" aria-label="Up">▲</button>
    <button class="empty" tabindex="-1" aria-hidden="true"></button>
    <button data-key="a" aria-label="Left">◀</button>
    <button data-key="s" aria-label="Down">▼</button>
    <button data-key="d" aria-label="Right">▶</button>
    <button class="empty" tabindex="-1" aria-hidden="true"></button>
    <button class="empty" tabindex="-1" aria-hidden="true"></button>
    <button class="empty" tabindex="-1" aria-hidden="true"></button>
  </div>
  <div class="actions">
    <button data-key="j">Stab</button>
    <button data-key="k">Jump</button>
  </div>
</div>

<script>
  // Basic Zelda II style platformer prototype
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // World / tile setup
  const TILE_SIZE = 16;
  const WORLD_COLS = Math.floor(canvas.width / TILE_SIZE);
  const WORLD_ROWS = Math.floor(canvas.height / TILE_SIZE);

  // Simple tile map: 0 = empty, 1 = solid
  const world = [];
  // Generate every row of the tile map so we can define solid/empty space per column.
  for (let y = 0; y < WORLD_ROWS; y++) {
    const row = [];
    // Populate the current row column-by-column to decide which cells are solid.
    for (let x = 0; x < WORLD_COLS; x++) {
      // Fill the final two rows with ground tiles so the player always has a floor.
      if (y === WORLD_ROWS - 2 || y === WORLD_ROWS - 1) {
        row.push(1);
      // Carve out a floating platform across the specified range to add variety.
      } else if (y === WORLD_ROWS - 6 && x > 5 && x < 12) {
        // Floating platform
        row.push(1);
      // Leave all other cells empty so they behave like air.
      } else {
        row.push(0);
      }
    }
    // Append the fully built row into the world layout.
    world.push(row);
  }

  // Player properties: 2 tiles tall, 1 tile wide
  const player = {
    x: 4 * TILE_SIZE,
    y: (WORLD_ROWS - 4) * TILE_SIZE,
    width: TILE_SIZE,
    height: TILE_SIZE * 2,
    standHeight: TILE_SIZE * 2,
    crouchHeight: Math.floor(TILE_SIZE * 1.5),
    vx: 0,
    vy: 0,
    speed: 2.2,
    jumpSpeed: -7,
    gravity: 0.35,
    maxFall: 10,
    onGround: false,
    facing: 1, // 1 right, -1 left
    crouching: false,
    attacking: false,
    attackTimer: 0,
    hitTimer: 0,
    attackWindup: 2,
    attackStab: 6,
    attackRecover: 3,
    get attackDuration() {
      return this.attackWindup + this.attackStab + this.attackRecover;
    }
  };

  // Simple Octorok enemy: 1 tile high
  const octorok = {
    x: 19 * TILE_SIZE,
    y: (WORLD_ROWS - 3) * TILE_SIZE,
    width: TILE_SIZE,
    height: TILE_SIZE,
    vx: 0,
    vy: 0,
    gravity: 0.30,
    maxFall: 8,
    onGround: false,
    jumpSpeed: -3.4,
    hitTimer: 0,
    prevVy: 0,
    shotThisJump: false,
    state: 'waitAfterShot', // initial delay before starting pattern
    stateTimer: 120
  };

  const rocks = [];
  const particles = [];

  // Input
  const keys = {
    w: false,
    a: false,
    s: false,
    d: false,
    j: false,
    k: false
  };

  const activePointers = new Map();

  // Release buttons that still track a pointer id or clear a specific button entirely.
  function releasePointerFromButtons(pointerId, specificButton) {
    // Iterate over each button that still has one or more active pointers.
    for (const [btn, set] of activePointers.entries()) {
      // Skip buttons that don't match the requested target.
      if (specificButton && btn !== specificButton) continue;
      // Skip buttons that do not contain the pointer we are clearing.
      if (pointerId !== undefined && !set.has(pointerId)) continue;

      // Drop the specific pointer id or clear the entire button when no id is provided.
      if (pointerId !== undefined) {
        set.delete(pointerId);
      } else {
        set.clear();
      }

      // Release the button entirely once no pointers remain associated with it.
      if (set.size === 0) {
        activePointers.delete(btn);
        setKeyState(btn.dataset.key, false);
        btn.classList.remove('active');
      }

      // Exit early after clearing a matching button or pointer id to avoid extra work.
      if (specificButton || pointerId !== undefined) break;
    }
  }

  // Update the stored pressed state for a given virtual key.
  function setKeyState(key, pressed) {
    // Only update keys that are actually tracked to ignore stray inputs.
    if (key in keys) {
      keys[key] = pressed;
    }
  }

  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    // Only react to keys that are part of the control scheme.
    if (k in keys) {
      keys[k] = true;
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    // Only react to keys that are part of the control scheme.
    if (k in keys) {
      keys[k] = false;
      e.preventDefault();
    }
  });

  const touchControls = document.getElementById('touch-controls');
  // Only enable touch controls if the UI is present.
  if (touchControls) {
    const buttons = touchControls.querySelectorAll('button[data-key]');
    // Iterate over every virtual button so they all receive pointer handlers.
    buttons.forEach((btn) => {
      const key = btn.dataset.key;
      const getPointerSet = () => {
        let set = activePointers.get(btn);
        if (!set) {
          set = new Set();
          activePointers.set(btn, set);
        }
        return set;
      };

      const press = (e) => {
        e.preventDefault();
        btn.setPointerCapture(e.pointerId);
        const set = getPointerSet();
        if (set.has(e.pointerId)) return;
        const wasInactive = set.size === 0;
        set.add(e.pointerId);
        if (wasInactive) {
          setKeyState(key, true);
          btn.classList.add('active');
        }
      };

      const release = (e) => {
        // Guard against synthetic releases without a pointer event object.
        if (e) e.preventDefault();
        releasePointerFromButtons(e ? e.pointerId : undefined, btn);
      };

      btn.addEventListener('pointerdown', press);
      btn.addEventListener('pointerup', release);
      btn.addEventListener('pointercancel', release);
    });
    // Ensure keys release if pointer leaves the browser viewport entirely.
    window.addEventListener('pointerup', (e) => {
      // Release whichever button was tracking this pointer id.
      releasePointerFromButtons(e.pointerId);
    });
    window.addEventListener('pointercancel', (e) => {
      // Release any button associated with a cancelled pointer gesture.
      releasePointerFromButtons(e.pointerId);
    });
    window.addEventListener('blur', () => {
      // Clear every button when the tab loses focus to avoid stuck inputs.
      releasePointerFromButtons();
    });
  }

  // Look up the tile index that occupies the given pixel coordinate.
  function tileAtPixel(x, y) {
    const tx = Math.floor(x / TILE_SIZE);
    const ty = Math.floor(y / TILE_SIZE);
    // Treat coordinates outside the map as solid so entities cannot leave the world.
    if (tx < 0 || ty < 0 || tx >= WORLD_COLS || ty >= WORLD_ROWS) return 1; // treat outside as solid
    return world[ty][tx];
  }

  // Determine whether a rectangle collides with any solid world tiles.
  function rectVsWorld(x, y, width, height) {
    // Check multiple points along the edges so we don't slip into tiles from the side
    const left = x;
    const right = x + width;
    const top = y;
    const bottom = y + height;
    const midY = (top + bottom) / 2;

    // Abort when the top-left corner hits something solid.
    if (tileAtPixel(left, top)) return true;
    // Abort when the top-right corner hits something solid.
    if (tileAtPixel(right - 1, top)) return true;
    // Abort when the mid-left sample hits something solid.
    if (tileAtPixel(left, midY)) return true;
    // Abort when the mid-right sample hits something solid.
    if (tileAtPixel(right - 1, midY)) return true;
    // Abort when the bottom-left corner hits something solid.
    if (tileAtPixel(left, bottom - 1)) return true;
    // Abort when the bottom-right corner hits something solid.
    if (tileAtPixel(right - 1, bottom - 1)) return true;
    return false;
  }

  // Build the sword's collision box when Link is in the stab phase of his attack.
  function swordHitbox() {
    // Skip collision while no attack is in progress.
    if (!player.attacking) return null;
    const t = player.attackTimer;
    // Only show the sword hitbox during the active stab frames.
    if (t < player.attackWindup || t >= player.attackWindup + player.attackStab) return null;

    // Match the main stab phase sword position roughly
    const swordLength = TILE_SIZE;
    const swordWidth = 4;
    const x = player.facing > 0 ? player.x + player.width : player.x - swordLength;
    const baseOffset = player.crouching ? player.height - TILE_SIZE / 2 : TILE_SIZE - swordWidth;
    const y = player.y + baseOffset;
    return { x, y, width: swordLength, height: swordWidth };
  }

  // Perform a simple AABB overlap check.
  function rectsOverlap(a, b) {
    return !(
      a.x + a.width <= b.x ||
      a.x >= b.x + b.width ||
      a.y + a.height <= b.y ||
      a.y >= b.y + b.height
    );
  }

  // Create a new octorok projectile and add it to the active list.
  function spawnRock(x, y, vx, vy) {
    rocks.push({
      x,
      y,
      vx,
      vy,
      size: 6,
      alive: true
    });
  }

  // Emit a radial burst of particles when a rock shatters.
  function spawnRockExplosion(x, y) {
    const count = 8;
    // Launch each particle in an even spread to mimic a burst.
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = 1.5 + Math.random();
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 18
      });
    }
  }

  // Advance the octorok AI, including movement, attacks, and reactions to damage.
  function updateOctorok() {
    octorok.prevVy = octorok.vy;

    // State machine: jump+shoot -> wait -> ground shoot -> wait -> repeat
    // Disabled while in hitstun
    // Only process the AI state machine when not currently in hitstun.
    if (octorok.hitTimer === 0) {
      // React only to the two waiting states because the others are instantaneous.
      if (octorok.state === 'waitAfterShot' || octorok.state === 'waitAfterJump') {
        // Count down the wait timer until it reaches zero.
        if (octorok.stateTimer > 0) {
          octorok.stateTimer--;
        }
        // Transition once the wait timer completes.
        if (octorok.stateTimer <= 0) {
          // Start the aerial attack cycle after finishing the post-shot delay.
          if (octorok.state === 'waitAfterShot') {
            // Begin jump phase
            // Initiate the jump only when the enemy is standing on ground.
            if (octorok.onGround) {
              octorok.vy = octorok.jumpSpeed;
              octorok.onGround = false;
            }
            octorok.shotThisJump = false;
            octorok.state = 'jump';
          // Fire a grounded shot when emerging from the waiting state after a jump.
          } else if (octorok.state === 'waitAfterJump') {
            // Grounded shot
            const mouthSize = 4;
            const mouthX = octorok.x - 2;
            const mouthY = octorok.y + octorok.height / 2 - mouthSize / 2;
            spawnRock(mouthX - 2, mouthY, -2.5, 0);
            // Now wait again before the next jump+shoot
            octorok.state = 'waitAfterShot';
            octorok.stateTimer = 60;
          }
        }
      }
    }

    // Gravity
    octorok.vy += octorok.gravity;
    // Clamp falling speed so gravity does not accelerate forever.
    if (octorok.vy > octorok.maxFall) octorok.vy = octorok.maxFall;

    // Horizontal movement from knockback
    let newX = octorok.x + octorok.vx;
    // Move horizontally only if the destination is not blocked by terrain.
    if (!rectVsWorld(newX, octorok.y, octorok.width, octorok.height)) {
      octorok.x = newX;
    } else {
      octorok.vx = 0;
    }

    // Vertical collision
    let newY = octorok.y + octorok.vy;
    // Apply vertical motion as long as the body is not intersecting the map.
    if (!rectVsWorld(octorok.x, newY, octorok.width, octorok.height)) {
      octorok.y = newY;
      octorok.onGround = false;
    } else {
      // Resolve downward collisions differently from upward collisions.
      if (octorok.vy > 0) {
        // Step the sprite down until touching ground so it lands cleanly.
        while (!rectVsWorld(octorok.x, octorok.y + 1, octorok.width, octorok.height)) {
          octorok.y += 1;
        }
        octorok.onGround = true;
        // When a jump finishes, transition into the waiting state.
        if (octorok.state === 'jump') {
          octorok.state = 'waitAfterJump';
          octorok.stateTimer = 60;
        }
      } else if (octorok.vy < 0) {
        // Step upward until the head clears the ceiling to avoid clipping.
        while (!rectVsWorld(octorok.x, octorok.y - 1, octorok.width, octorok.height)) {
          octorok.y -= 1;
        }
      }
      octorok.vy = 0;
    }

    // Friction on ground for knockback
    // Apply friction only when grounded so knockback tapers off.
    if (octorok.onGround) {
      octorok.vx *= 0.85;
      // Zero-out extremely tiny velocities to avoid jittering.
      if (Math.abs(octorok.vx) < 0.05) octorok.vx = 0;
    }

    const wasHit = octorok.hitTimer > 0;
    // Count down hitstun frames until the enemy recovers.
    if (octorok.hitTimer > 0) {
      octorok.hitTimer--;
    }

    // Shoot a rock at the apex of the jump during the jump phase (no shooting while in hitstun)
    if (octorok.hitTimer === 0 &&
        !octorok.onGround && !octorok.shotThisJump &&
        octorok.prevVy <= 0 && octorok.vy > 0 &&
        octorok.state === 'jump') {
      const mouthSize = 4;
      const mouthX = octorok.x - 2;
      const mouthY = octorok.y + octorok.height / 2 - mouthSize / 2;
      spawnRock(mouthX - 2, mouthY, -2.5, 0);
      octorok.shotThisJump = true;
    }

    // When hitstun ends, reset the pattern
    if (wasHit && octorok.hitTimer === 0) {
      octorok.state = 'waitAfterShot';
      octorok.stateTimer = 60;
      octorok.shotThisJump = false;
    }
  }

  // Compute the player's shield hitbox, accounting for crouching and facing.
  function shieldHitbox() {
    const shieldWidth = TILE_SIZE * 0.6;
    const shieldHeight = TILE_SIZE;
    let shieldY;
    // Anchor the shield lower while crouching so it covers Link's knees.
    if (player.crouching) {
      shieldY = player.y + player.height - shieldHeight;
    } else {
      shieldY = player.y + TILE_SIZE * 0.2;
    }
    let shieldX;
    // Offset the shield based on facing so it always sits in front of Link.
    if (player.facing > 0) {
      shieldX = player.x + player.width - shieldWidth + 1;
    } else {
      shieldX = player.x - 1;
    }
    return {
      x: shieldX,
      y: shieldY,
      width: shieldWidth,
      height: shieldHeight
    };
  }

  // Move active projectiles and particles while handling their collisions.
  function updateRocksAndParticles() {
    // Rocks
    // Step through each projectile to update its physics and collisions.
    for (const rock of rocks) {
      // Skip rocks that already exploded so they don't keep updating.
      if (!rock.alive) continue;
      rock.x += rock.vx;
      rock.y += rock.vy;

      const rockBox = {
        x: rock.x,
        y: rock.y,
        width: rock.size,
        height: rock.size
      };

      const shieldBox = shieldHitbox();
      const playerBox = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };

      let exploded = false;
      // Shield blocks the rock
      if (rectsOverlap(rockBox, shieldBox)) {
        exploded = true;
      } else if (rectsOverlap(rockBox, playerBox) && player.hitTimer === 0) {
        // Hit the player
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const projCenter = rock.x + rock.size / 2;
        const dir = playerCenter < projCenter ? -1 : 1;
        player.vx = dir * 3.0;
        player.vy = -4;
        player.attacking = false;
        player.attackTimer = 0;
        exploded = true;
      }

      // Offscreen
      // Blow up the projectile if it wanders off-screen to keep arrays small.
      if (rock.x + rock.size < 0 || rock.x > canvas.width ||
          rock.y + rock.size < 0 || rock.y > canvas.height) {
        exploded = true;
      }

      // Convert the rock into particles after any collision or despawn event.
      if (exploded) {
        rock.alive = false;
        spawnRockExplosion(rock.x + rock.size / 2, rock.y + rock.size / 2);
      }
    }

    // Compact rocks array
    // Walk the array backwards so splices do not skip entries.
    for (let i = rocks.length - 1; i >= 0; i--) {
      // Remove any rock marked as dead to prevent future updates.
      if (!rocks[i].alive) rocks.splice(i, 1);
    }

    // Particles
    // Update each particle's position and fade over time.
    for (const p of particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.05;
      p.life--;
    }
    // Clean up expired particles from the tail end first.
    for (let i = particles.length - 1; i >= 0; i--) {
      if (particles[i].life <= 0) particles.splice(i, 1);
    }
  }

  // Handle player input, physics, combat, and reactions to damage.
  function updatePlayer() {
    // Horizontal input (used for facing even while attacking)
    let inputDir = 0;
    // Tilt left when A is held down.
    if (keys.a) inputDir -= 1;
    // Tilt right when D is held down.
    if (keys.d) inputDir += 1;

    const lockMovement = (player.attacking && player.onGround) || player.hitTimer > 0;
    const moveX = lockMovement ? 0 : inputDir;

    // Crouch (S) can be used on ground or in air,
    // but you can't change crouch state during an attack
    const wasCrouching = player.crouching;
    // Allow crouch toggles only when not attacking or flinching.
    if (!player.attacking && player.hitTimer === 0) {
      player.crouching = keys.s;
    }

    // Adjust collision box when crouching / standing
    if (player.crouching !== wasCrouching) {
      // Shrink the player's collider whenever crouching begins.
      if (player.crouching) {
        const delta = player.standHeight - player.crouchHeight;
        player.y += delta;
        player.height = player.crouchHeight;
      // Try to return to full height if the crouch is released.
      } else {
        const delta = player.standHeight - player.crouchHeight;
        const newY = player.y - delta;
        // Only stand up if there is room
        if (!rectVsWorld(player.x, newY, player.width, player.standHeight)) {
          player.y = newY;
          player.height = player.standHeight;
        } else {
          // Stay crouched if overhead terrain blocks the stand-up attempt.
          player.crouching = true;
        }
      }
    }

    // Facing direction (ignore zero movement)
    if (inputDir !== 0) {
      player.facing = inputDir > 0 ? 1 : -1;
    }

    // Apply horizontal velocity (no air control damping)
    // During hit-stun, preserve knockback velocity instead of overriding it
    // Only override movement while Link is not recoiling from damage.
    if (player.hitTimer === 0) {
      player.vx = moveX * player.speed;
    }

    // Jump (K)
    // Trigger a jump when K is pressed while grounded and free to move.
    if (keys.k && player.onGround && !player.attacking && player.hitTimer === 0) {
      player.vy = player.jumpSpeed;
      player.onGround = false;
    }

    // Gravity
    player.vy += player.gravity;
    // Prevent falling speed from exceeding the cap.
    if (player.vy > player.maxFall) player.vy = player.maxFall;

    // Horizontal collision
    let newX = player.x + player.vx;
    // Slide freely when the path ahead is clear.
    if (!rectVsWorld(newX, player.y, player.width, player.height)) {
      player.x = newX;
    } else {
      // slide
      // Walk pixel-by-pixel into the wall to land flush without overlapping.
      while (!rectVsWorld(player.x + Math.sign(player.vx), player.y, player.width, player.height)) {
        player.x += Math.sign(player.vx);
      }
      player.vx = 0;
    }

    // Vertical collision
    let newY = player.y + player.vy;
    // Allow freefall whenever the new position is unobstructed.
    if (!rectVsWorld(player.x, newY, player.width, player.height)) {
      player.y = newY;
      player.onGround = false;
    } else {
      // Handle downward impacts differently from upward hits.
      if (player.vy > 0) {
        // Landing on ground
        // Step downward until feet touch the floor to avoid sinking.
        while (!rectVsWorld(player.x, player.y + 1, player.width, player.height)) {
          player.y += 1;
        }
        player.onGround = true;
      } else if (player.vy < 0) {
        // Hitting ceiling
        // Step upward until the head clears to keep the body outside tiles.
        while (!rectVsWorld(player.x, player.y - 1, player.width, player.height)) {
          player.y -= 1;
        }
      }
      player.vy = 0;
    }

    // Attack (J) - standing or crouching allowed
    // Start a new stab when J is pressed and Link is free to act.
    if (keys.j && !player.attacking && player.hitTimer === 0) {
      player.attacking = true;
      player.attackTimer = 0;
    }

    // Count through the attack animation frames.
    if (player.attacking) {
      player.attackTimer++;
      // End the attack when the animation timer completes.
      if (player.attackTimer >= player.attackDuration) {
        player.attacking = false;
        player.attackTimer = 0;
      }
    }

    // Taper off hurt invulnerability each frame until it hits zero.
    if (player.hitTimer > 0) {
      player.hitTimer--;
    }

    // Sword vs Octorok
    const sword = swordHitbox();
    // Damage the enemy whenever the sword hitbox overlaps and it's vulnerable.
    if (sword && rectsOverlap(sword, octorok) && octorok.hitTimer === 0) {
      octorok.hitTimer = 10;
      const knockDir = player.facing;
      octorok.vx = 3 * knockDir;
      octorok.vy = -2.5;
    }

    // Player touching Octorok -> knockback + flash
    // Only check direct body collisions if Link is not currently invulnerable.
    if (player.hitTimer === 0) {
      const playerBox = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };
      // Trigger damage handling whenever Link's body overlaps the enemy.
      if (rectsOverlap(playerBox, octorok)) {
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const enemyCenter = octorok.x + octorok.width / 2;
        const dir = playerCenter < enemyCenter ? -1 : 1; // knock away from enemy

        // Immediately separate horizontally so we don't stay overlapping
        // Push Link to the left if he was left of center.
        if (dir < 0) {
          player.x = octorok.x - player.width - 1;
        } else {
          // Otherwise push him to the right side of the enemy.
          player.x = octorok.x + octorok.width + 1;
        }

        player.vx = dir * 3.2;
        player.vy = -4;
        player.attacking = false;
        player.attackTimer = 0;
      }
    }
  }

  // Render the tile-based ground layout.
  function drawWorld() {
    // Walk across each row to draw the visible tiles.
    for (let y = 0; y < WORLD_ROWS; y++) {
      // Inspect every column within the current row.
      for (let x = 0; x < WORLD_COLS; x++) {
        // Paint solid tiles only so empty cells stay transparent.
        if (world[y][x] === 1) {
          ctx.fillStyle = '#303060';
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = '#505090';
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, 4);
        }
      }
    }
  }

  // Draw the octorok enemy with its simple animation cues.
  function drawOctorok() {
    const x = Math.floor(octorok.x);
    const y = Math.floor(octorok.y);
    const w = octorok.width;
    const h = octorok.height;

    // Flash when hit
    if (octorok.hitTimer > 0 && (octorok.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#ff7040';
    }
    ctx.fillRect(x, y, w, h);

    // Simple eyes
    ctx.fillStyle = '#000000';
    ctx.fillRect(x + 3, y + 4, 3, 3);
    ctx.fillRect(x + w - 6, y + 4, 3, 3);

    // Little mouth on its left side
    ctx.fillStyle = '#602020';
    const mouthWidth = 4;
    const mouthHeight = 3;
    const mouthX = x - 1;
    const mouthY = y + h / 2 - mouthHeight / 2;
    ctx.fillRect(Math.floor(mouthX), Math.floor(mouthY), mouthWidth, mouthHeight);
  }

  // Render the player character, including sword and shield.
  function drawPlayer() {
    // Base body color (flash when hit)
    if (player.hitTimer > 0 && (player.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#2f9e44';
    }

    // Body (simple rectangle)
    ctx.fillRect(Math.floor(player.x), Math.floor(player.y), player.width, player.height);

    // Head (top section)
    const headHeight = Math.min(TILE_SIZE, player.height);
    if (player.hitTimer > 0 && (player.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#ffe6a0';
    }
    ctx.fillRect(Math.floor(player.x), Math.floor(player.y), player.width, headHeight);

    // Simple helmet / hair band
    ctx.fillStyle = '#40a040';
    ctx.fillRect(Math.floor(player.x), Math.floor(player.y), player.width, 4);

    // Shield (position depends on crouch / stand)
    const sBox = shieldHitbox();
    ctx.fillStyle = '#b0c0ff';
    ctx.fillRect(Math.floor(sBox.x), Math.floor(sBox.y), sBox.width, sBox.height);
    ctx.fillStyle = '#8090d0';
    ctx.fillRect(Math.floor(sBox.x) + 1, Math.floor(sBox.y) + 2, sBox.width - 2, sBox.height - 4);

    // Sword stab
    if (player.attacking) {
      const t = player.attackTimer;
      let phase = 'recover';
      // Treat early frames as the windup phase.
      if (t < player.attackWindup) {
        phase = 'windup';
      // Treat middle frames as the thrusting phase.
      } else if (t < player.attackWindup + player.attackStab) {
        phase = 'stab';
      }

      // Length / offset by phase
      let swordLength = TILE_SIZE;
      let forwardAdjust = 0;
      // Shorten and retract the blade during the windup.
      if (phase === 'windup') {
        swordLength = TILE_SIZE / 2;
        forwardAdjust = -swordLength / 2;
      // Shorten again while recovering to mimic pulling back.
      } else if (phase === 'recover') {
        swordLength = TILE_SIZE / 2;
        forwardAdjust = -swordLength / 4;
      }

      ctx.fillStyle = '#f8f8f8';
      const swordWidth = 4;
      const swordX = player.facing > 0
        ? player.x + player.width + forwardAdjust
        : player.x - swordLength - forwardAdjust;
      // Lower sword when crouching
      const baseOffset = player.crouching ? player.height - TILE_SIZE / 2 : TILE_SIZE - swordWidth;
      const swordY = player.y + baseOffset;
      ctx.fillRect(Math.floor(swordX), Math.floor(swordY), swordLength, swordWidth);

      // Hilt
      ctx.fillStyle = '#c8a060';
      const hiltX = player.facing > 0
        ? swordX - 3
        : swordX + swordLength - 1;
      ctx.fillRect(Math.floor(hiltX), Math.floor(swordY - 2), 6, 2);
    }
  }

  // Main game loop that advances simulation and rendering frames.
  function loop() {
    updatePlayer();
    updateOctorok();
    updateRocksAndParticles();

    // Clear
    ctx.fillStyle = '#202048';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawWorld();
    drawPlayer();
    drawOctorok();

    // Draw rocks
    // Iterate over every active projectile to display it.
    for (const rock of rocks) {
      ctx.fillStyle = '#d0b090';
      ctx.fillRect(Math.floor(rock.x), Math.floor(rock.y), rock.size, rock.size);
    }

    // Draw particles
    // Iterate across each particle puff to render the debris cloud.
    for (const p of particles) {
      ctx.fillStyle = 'rgba(255, 220, 160, 0.8)';
      ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 2, 2);
    }

    requestAnimationFrame(loop);
  }

  loop();
</script>
</body>
</html>
