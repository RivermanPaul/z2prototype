<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Documentation policy: comment every function, conditional, and loop to describe its role. -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <title>Zelda II HTML5 Prototype</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      user-select: none;
      -webkit-user-select: none;
      min-height: 100vh;
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }
    #game-layout {
      width: 100%;
      max-width: 960px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 24px 16px 48px;
      box-sizing: border-box;
    }
    #game-stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      margin: 0 auto;
      background: #202048;
      max-width: 100%;
      height: auto;
    }
    #info {
      text-align: center;
      margin-top: 8px;
      font-size: 14px;
    }
    #info kbd {
      padding: 1px 4px;
      border-radius: 3px;
      border: 1px solid #555;
      background: #222;
      font-family: monospace;
      font-size: 12px;
    }
    #touch-controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 24px;
      margin: 18px auto 32px;
      max-width: 520px;
      padding: 0 16px;
      user-select: none;
      touch-action: manipulation;
    }
    #touch-controls button {
      width: 64px;
      height: 64px;
      border-radius: 14px;
      border: 2px solid #555;
      background: #1d1d2e;
      color: #eee;
      font-size: 18px;
      font-weight: 600;
      text-transform: uppercase;
      box-shadow: inset 0 2px 0 rgba(255,255,255,0.05);
      transition: transform 0.1s ease, background 0.1s ease;
      user-select: none;
      -webkit-user-select: none;
    }
    #touch-controls button:active,
    #touch-controls button.active {
      background: #353562;
      transform: translateY(2px);
    }
    #touch-controls .dpad {
      display: grid;
      grid-template-columns: repeat(3, 64px);
      grid-template-rows: repeat(3, 64px);
      gap: 8px;
    }
    #touch-controls .dpad button {
      font-size: 20px;
    }
    #touch-controls .dpad button.empty {
      visibility: hidden;
      pointer-events: none;
    }
    #touch-controls .actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #touch-controls .actions button {
      width: 88px;
    }
    @media (max-width: 480px) {
      #touch-controls {
        gap: 16px;
      }
      #touch-controls button {
        width: 56px;
        height: 56px;
      }
      #touch-controls .dpad {
        grid-template-columns: repeat(3, 56px);
        grid-template-rows: repeat(3, 56px);
      }
      #touch-controls .actions button {
        width: 72px;
      }
    }
    .mobile-landscape body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      width: 100vw;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .mobile-landscape #game-layout {
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 32px;
      max-width: none;
      width: 100%;
      height: 100%;
      padding: 0 24px;
      box-sizing: border-box;
    }
    .mobile-landscape #game-stage {
      flex: 1 1 auto;
    }
    .mobile-landscape canvas {
      width: min(calc((100vh - 48px) * 512 / 288), calc(100vw - 220px));
      max-width: none;
      height: auto;
    }
    .mobile-landscape #touch-controls {
      margin: 0;
      flex-direction: column;
      flex-wrap: nowrap;
      gap: 18px;
      max-width: none;
      padding: 0;
    }
    .mobile-landscape #info {
      position: absolute;
      bottom: env(safe-area-inset-bottom, 16px);
      left: 50%;
      transform: translateX(-50%);
      margin-top: 0;
      font-size: 12px;
      opacity: 0.85;
    }
  </style>
</head>
<body>
<div id="game-layout">
  <div id="game-stage">
    <canvas id="game" width="512" height="288"></canvas>
    <div id="info">
      Controls:
      <kbd>W</kbd>/<kbd>A</kbd>/<kbd>S</kbd>/<kbd>D</kbd> move &amp; crouch,
      <kbd>K</kbd> jump,
      <kbd>J</kbd> stab
    </div>
  </div>
  <div id="touch-controls">
    <div class="dpad">
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button data-key="w" aria-label="Up">▲</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button data-key="a" aria-label="Left">◀</button>
      <button data-key="s" aria-label="Down">▼</button>
      <button data-key="d" aria-label="Right">▶</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
    </div>
    <div class="actions">
      <button data-key="j">Stab</button>
      <button data-key="k">Jump</button>
    </div>
  </div>
</div>

<script>
  // Prevent browser UI gestures (scrolling, pinch-zoom, etc.) from interrupting gameplay.
  window.addEventListener('gesturestart', (event) => {
    event.preventDefault();
  });
  // Block scrolling that could be triggered by touchmove events while using on-screen controls.
  window.addEventListener('touchmove', (event) => {
    event.preventDefault();
  }, { passive: false });

  // Basic Zelda II style platformer prototype
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Track whether we are on a small viewport so we can optimize the layout for mobile screens.
  const mobileMediaQuery = window.matchMedia('(max-width: 768px)');

  // Function that toggles a helper class when the layout should stretch to a full-screen landscape view.
  function syncMobileLayoutClass() {
    // Identify when we are both on a mobile-sized viewport and currently in landscape orientation.
    const inLandscapeMobile = mobileMediaQuery.matches && window.matchMedia('(orientation: landscape)').matches;
    // Add the helper class so CSS can drive the full-screen layout in mobile landscape.
    if (inLandscapeMobile) {
      document.documentElement.classList.add('mobile-landscape');
    // Remove the class whenever we leave the mobile landscape configuration.
    } else {
      document.documentElement.classList.remove('mobile-landscape');
    }
  }

  // Ensure the helper class matches the current viewport before the game starts running.
  syncMobileLayoutClass();
  // Update the layout helper class whenever the viewport changes dimensions.
  window.addEventListener('resize', syncMobileLayoutClass);
  window.addEventListener('orientationchange', syncMobileLayoutClass);

  // Attempt to lock the screen orientation to landscape on mobile browsers that support the API for a more immersive view.
  if (mobileMediaQuery.matches && 'orientation' in screen && typeof screen.orientation.lock === 'function') {
    screen.orientation.lock('landscape').catch(() => {});
  }

  // World / tile setup
  const TILE_SIZE = 16;
  const WORLD_ROWS = Math.floor(canvas.height / TILE_SIZE);
  const SCREEN_COLS = Math.floor(canvas.width / TILE_SIZE);
  const AREA_SCREEN_COUNT = 2;
  const AREA_COLS = SCREEN_COLS * AREA_SCREEN_COUNT;
  const AREA_WIDTH = AREA_COLS * TILE_SIZE;

  // Cache of generated areas so we only build each layout once.
  const areaCache = new Map();
  // Cache enemy instances per area so we can preserve their state when revisiting rooms.
  const areaEntities = new Map();

  // Produce the tile grid for a given area index.
  function generateAreaTiles(areaIndex) {
    const tiles = [];
    // Build the base ground/air layout row-by-row.
    // Iterate over each world row so we can fill in the ground pattern.
    for (let y = 0; y < WORLD_ROWS; y++) {
      const row = [];
      // Populate the row column-by-column so every cell receives either solid ground or air.
      for (let x = 0; x < AREA_COLS; x++) {
        // Keep the bottom two rows solid to act as ground just like the original room.
        if (y === WORLD_ROWS - 2 || y === WORLD_ROWS - 1) {
          row.push(1);
        } else {
          row.push(0);
        }
      }
      tiles.push(row);
    }

    // Add floating platforms. Each step to the right gains one more platform, steps to the
    // left remove one, and the base area starts with a single platform.
    const platformCount = Math.max(0, areaIndex + 1);
    const platformRow = WORLD_ROWS - 6;
    const platformWidth = 6;
    if (platformRow >= 0 && platformCount > 0) {
      const spacing = AREA_COLS / (platformCount + 1);
      // Step through each platform slot so we can drop solid ledges across the span.
      for (let i = 0; i < platformCount; i++) {
        const center = Math.round(spacing * (i + 1));
        const start = Math.max(1, Math.min(AREA_COLS - platformWidth - 1, Math.floor(center - platformWidth / 2)));
        // Fill every tile covered by the platform with solid cells.
        for (let x = start; x < start + platformWidth; x++) {
          tiles[platformRow][x] = 1;
        }
      }
    }

    return tiles;
  }

  // Return (and lazily build) the tile array for the requested area index.
  function getAreaTiles(areaIndex) {
    if (!areaCache.has(areaIndex)) {
      areaCache.set(areaIndex, generateAreaTiles(areaIndex));
    }
    return areaCache.get(areaIndex);
  }

  // Return the list of area indices that overlap the current camera view (with padding for nearby rooms).
  function getVisibleAreaIndices() {
    const start = Math.floor(cameraX / AREA_WIDTH) - 1;
    const end = Math.floor((cameraX + canvas.width) / AREA_WIDTH) + 1;
    const indices = [];
    // Step through each area index that may appear within or near the viewport so we can activate their entities.
    for (let areaIndex = start; areaIndex <= end; areaIndex++) {
      indices.push(areaIndex);
    }
    return indices;
  }

  // Build an octorok instance positioned at the requested world coordinates.
  function createOctorokAt(x, y) {
    return {
      x,
      y,
      width: TILE_SIZE,
      height: TILE_SIZE,
      vx: 0,
      vy: 0,
      gravity: 0.30,
      maxFall: 8,
      onGround: false,
      jumpSpeed: -3.4,
      hitTimer: 0,
      prevVy: 0,
      shotThisJump: false,
      state: 'waitAfterShot',
      stateTimer: 120,
      idleAnimTimer: 0,
      idleAnimFrame: 0
    };
  }

  // Create an Armos Knight that stands at the requested world coordinates.
  function createArmosKnightAt(x, y) {
    return {
      x,
      y,
      width: TILE_SIZE,
      height: TILE_SIZE * 2,
      vx: 0,
      facing: -1,
      attacking: false,
      attackTimer: 0,
      attackWindup: 30,
      attackStab: 12,
      attackRecover: 18,
      attackCooldown: 180 + Math.floor(Math.random() * 60),
      attackHeight: 'high',
      hitTimer: 0,
      shieldHigh: true,
      shieldChangeTimer: 0,
      knockbackTimer: 0,
      get attackDuration() {
        return this.attackWindup + this.attackStab + this.attackRecover;
      }
    };
  }

  // Locate a suitable platform within the requested area so the resident octorok can perch on it.
  function findOctorokSpawn(areaIndex, areaTiles) {
    const platformRow = WORLD_ROWS - 6;
    // Abort when the configured platform row falls outside the world height.
    if (platformRow < 0 || platformRow >= WORLD_ROWS) return null;
    const spans = [];
    let spanStart = -1;
    // Scan the entire row to collect contiguous stretches of solid tiles that represent platforms.
    for (let x = 0; x < AREA_COLS; x++) {
      // Begin tracking a new platform span whenever a floating solid tile appears after empty space.
      if (areaTiles[platformRow][x] === 1 && areaTiles[platformRow + 1][x] === 0) {
        // Start the span at the current column if we are not already tracking one.
        if (spanStart === -1) {
          spanStart = x;
        }
      // Close out the span as soon as we return to air tiles.
      } else if (spanStart !== -1) {
        spans.push({ start: spanStart, end: x - 1 });
        spanStart = -1;
      }
    }
    // Ensure the trailing platform is recorded if the row ends on a solid tile.
    if (spanStart !== -1) {
      spans.push({ start: spanStart, end: AREA_COLS - 1 });
    }
    // Skip spawning if the area has no floating platforms.
    if (spans.length === 0) return null;
    const targetCenter = AREA_COLS / 2;
    let bestSpan = spans[0];
    let smallestDistance = Infinity;
    // Choose the platform whose center sits closest to the area's midpoint so the fight feels balanced.
    for (const span of spans) {
      // Measure how far the current span is from the center so we can keep the closest one.
      const center = (span.start + span.end + 1) / 2;
      const distance = Math.abs(center - targetCenter);
      // Keep whichever span minimizes the distance to the center to reduce travel time.
      if (distance < smallestDistance) {
        smallestDistance = distance;
        bestSpan = span;
      }
    }
    const centerTile = (bestSpan.start + bestSpan.end + 1) / 2;
    const spawnX = areaIndex * AREA_WIDTH + centerTile * TILE_SIZE - TILE_SIZE / 2;
    const spawnY = platformRow * TILE_SIZE - TILE_SIZE;
    return { x: spawnX, y: spawnY };
  }

  // Lazily generate the persistent enemy set that belongs to a specific area index.
  function getAreaEntities(areaIndex) {
    // Build the area's enemies the first time we request them so they persist afterward.
    if (!areaEntities.has(areaIndex)) {
      const tiles = getAreaTiles(areaIndex);
      const spawn = findOctorokSpawn(areaIndex, tiles);
      const octorok = spawn ? createOctorokAt(spawn.x, spawn.y) : null;
      const groundY = (WORLD_ROWS - 2) * TILE_SIZE - TILE_SIZE * 2;
      const knightX = areaIndex * AREA_WIDTH + AREA_WIDTH / 2 - TILE_SIZE / 2;
      const armosKnight = createArmosKnightAt(knightX, groundY);
      areaEntities.set(areaIndex, { octorok, armosKnight });
    }
    return areaEntities.get(areaIndex);
  }

  // Track the current horizontal scroll position of the camera.
  let cameraX = 0;

  // Update the camera so it stays centered on Link while remaining inside the active area.
  function updateCamera() {
    const areaIndex = Math.floor(player.x / AREA_WIDTH);
    const areaStart = areaIndex * AREA_WIDTH;
    const areaEnd = areaStart + AREA_WIDTH;
    const target = player.x + player.width / 2 - canvas.width / 2;
    const minCam = areaStart;
    const maxCam = areaEnd - canvas.width;
    cameraX = Math.min(Math.max(target, minCam), maxCam);
  }

  // Duration of the player's walking animation frames in ticks.
  const WALK_ANIM_FRAME_DURATION = 6;
  // Duration of the Octorok's idle animation frames in ticks.
  const OCTOROK_IDLE_FRAME_DURATION = 24;

  // Player properties: 2 tiles tall, 1 tile wide
  const player = {
    x: 4 * TILE_SIZE,
    y: (WORLD_ROWS - 4) * TILE_SIZE,
    width: TILE_SIZE,
    height: TILE_SIZE * 2,
    standHeight: TILE_SIZE * 2,
    crouchHeight: Math.floor(TILE_SIZE * 1.5),
    vx: 0,
    vy: 0,
    speed: 2.2,
    jumpSpeed: -7,
    gravity: 0.35,
    maxFall: 10,
    onGround: false,
    facing: 1, // 1 right, -1 left
    crouching: false,
    attacking: false,
    attackTimer: 0,
    hitTimer: 0,
    attackWindup: 2,
    attackStab: 6,
    attackRecover: 3,
    blockedThisSwing: false,
    walking: false,
    walkAnimTimer: 0,
    walkAnimFrame: 0,
    get attackDuration() {
      return this.attackWindup + this.attackStab + this.attackRecover;
    }
  };

  const rocks = [];
  const particles = [];

  // Input
  const keys = {
    w: false,
    a: false,
    s: false,
    d: false,
    j: false,
    k: false
  };

  const activePointers = new Map();

  // Release buttons that still track a pointer id or clear a specific button entirely.
  function releasePointerFromButtons(pointerId, specificButton) {
    // Iterate over each button that still has one or more active pointers.
    for (const [btn, set] of activePointers.entries()) {
      // Skip buttons that don't match the requested target.
      if (specificButton && btn !== specificButton) continue;
      // Skip buttons that do not contain the pointer we are clearing.
      if (pointerId !== undefined && !set.has(pointerId)) continue;

      // Drop the specific pointer id or clear the entire button when no id is provided.
      if (pointerId !== undefined) {
        set.delete(pointerId);
      } else {
        set.clear();
      }

      // Release the button entirely once no pointers remain associated with it.
      if (set.size === 0) {
        activePointers.delete(btn);
        setKeyState(btn.dataset.key, false);
        btn.classList.remove('active');
      }

      // Exit early after clearing a matching button or pointer id to avoid extra work.
      if (specificButton || pointerId !== undefined) break;
    }
  }

  // Update the stored pressed state for a given virtual key.
  function setKeyState(key, pressed) {
    // Only update keys that are actually tracked to ignore stray inputs.
    if (key in keys) {
      keys[key] = pressed;
    }
  }

  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    // Only react to keys that are part of the control scheme.
    if (k in keys) {
      keys[k] = true;
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    // Only react to keys that are part of the control scheme.
    if (k in keys) {
      keys[k] = false;
      e.preventDefault();
    }
  });

  const touchControls = document.getElementById('touch-controls');
  // Only enable touch controls if the UI is present.
  if (touchControls) {
    const buttons = touchControls.querySelectorAll('button[data-key]');
    // Iterate over every virtual button so they all receive pointer handlers.
    buttons.forEach((btn) => {
      const key = btn.dataset.key;
      const getPointerSet = () => {
        let set = activePointers.get(btn);
        if (!set) {
          set = new Set();
          activePointers.set(btn, set);
        }
        return set;
      };

      const press = (e) => {
        e.preventDefault();
        btn.setPointerCapture(e.pointerId);
        const set = getPointerSet();
        if (set.has(e.pointerId)) return;
        const wasInactive = set.size === 0;
        set.add(e.pointerId);
        if (wasInactive) {
          setKeyState(key, true);
          btn.classList.add('active');
        }
      };

      const release = (e) => {
        // Guard against synthetic releases without a pointer event object.
        if (e) e.preventDefault();
        releasePointerFromButtons(e ? e.pointerId : undefined, btn);
      };

      btn.addEventListener('pointerdown', press);
      btn.addEventListener('pointerup', release);
      btn.addEventListener('pointercancel', release);
    });
    // Ensure keys release if pointer leaves the browser viewport entirely.
    window.addEventListener('pointerup', (e) => {
      // Release whichever button was tracking this pointer id.
      releasePointerFromButtons(e.pointerId);
    });
    window.addEventListener('pointercancel', (e) => {
      // Release any button associated with a cancelled pointer gesture.
      releasePointerFromButtons(e.pointerId);
    });
    window.addEventListener('blur', () => {
      // Clear every button when the tab loses focus to avoid stuck inputs.
      releasePointerFromButtons();
    });
  }

  // Look up the tile index that occupies the given tile coordinate across any area.
  function tileAtTileCoordinates(tileX, tileY) {
    if (tileY < 0 || tileY >= WORLD_ROWS) return 1;
    const areaIndex = Math.floor(tileX / AREA_COLS);
    const localTileX = tileX - areaIndex * AREA_COLS;
    const areaTiles = getAreaTiles(areaIndex);
    if (localTileX < 0 || localTileX >= AREA_COLS) return 1;
    return areaTiles[tileY][localTileX];
  }

  // Look up the tile index that occupies the given pixel coordinate.
  function tileAtPixel(x, y) {
    const tx = Math.floor(x / TILE_SIZE);
    const ty = Math.floor(y / TILE_SIZE);
    return tileAtTileCoordinates(tx, ty);
  }

  // Determine whether a rectangle collides with any solid world tiles.
  function rectVsWorld(x, y, width, height) {
    // Check multiple points along the edges so we don't slip into tiles from the side
    const left = x;
    const right = x + width;
    const top = y;
    const bottom = y + height;
    const midY = (top + bottom) / 2;

    // Abort when the top-left corner hits something solid.
    if (tileAtPixel(left, top)) return true;
    // Abort when the top-right corner hits something solid.
    if (tileAtPixel(right - 1, top)) return true;
    // Abort when the mid-left sample hits something solid.
    if (tileAtPixel(left, midY)) return true;
    // Abort when the mid-right sample hits something solid.
    if (tileAtPixel(right - 1, midY)) return true;
    // Abort when the bottom-left corner hits something solid.
    if (tileAtPixel(left, bottom - 1)) return true;
    // Abort when the bottom-right corner hits something solid.
    if (tileAtPixel(right - 1, bottom - 1)) return true;
    return false;
  }

  // Build the sword's collision box when Link is in the stab phase of his attack.
  function swordHitbox() {
    // Skip collision while no attack is in progress.
    if (!player.attacking) return null;
    const t = player.attackTimer;
    // Only show the sword hitbox during the active stab frames.
    if (t < player.attackWindup || t >= player.attackWindup + player.attackStab) return null;

    // Match the main stab phase sword position roughly
    const swordLength = TILE_SIZE;
    const swordWidth = 4;
    const x = player.facing > 0 ? player.x + player.width : player.x - swordLength;
    // Lift the standing stab slightly so it can clear low shields.
    const standingSwordYOffset = TILE_SIZE - swordWidth - 2;
    const baseOffset = player.crouching ? player.height - TILE_SIZE / 2 : standingSwordYOffset;
    const y = player.y + baseOffset;
    return { x, y, width: swordLength, height: swordWidth };
  }

  // Perform a simple AABB overlap check.
  function rectsOverlap(a, b) {
    return !(
      a.x + a.width <= b.x ||
      a.x >= b.x + b.width ||
      a.y + a.height <= b.y ||
      a.y >= b.y + b.height
    );
  }

  // Create a new octorok projectile and add it to the active list.
  function spawnRock(x, y, vx, vy) {
    rocks.push({
      x,
      y,
      vx,
      vy,
      size: 6,
      alive: true
    });
  }

  // Emit a radial burst of particles when a rock shatters.
  function spawnRockExplosion(x, y) {
    const count = 8;
    // Launch each particle in an even spread to mimic a burst.
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = 1.5 + Math.random();
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 18
      });
    }
  }

  // Advance the octorok AI, including movement, attacks, and reactions to damage.
  function updateOctorok(octorok) {
    octorok.prevVy = octorok.vy;

    // State machine: jump+shoot -> wait -> ground shoot -> wait -> repeat
    // Disabled while in hitstun
    // Only process the AI state machine when not currently in hitstun.
    if (octorok.hitTimer === 0) {
      // React only to the two waiting states because the others are instantaneous.
      if (octorok.state === 'waitAfterShot' || octorok.state === 'waitAfterJump') {
        // Count down the wait timer until it reaches zero.
        if (octorok.stateTimer > 0) {
          octorok.stateTimer--;
        }
        // Transition once the wait timer completes.
        if (octorok.stateTimer <= 0) {
          // Start the aerial attack cycle after finishing the post-shot delay.
          if (octorok.state === 'waitAfterShot') {
            // Begin jump phase
            // Initiate the jump only when the enemy is standing on ground.
            if (octorok.onGround) {
              octorok.vy = octorok.jumpSpeed;
              octorok.onGround = false;
            }
            octorok.shotThisJump = false;
            octorok.state = 'jump';
          // Fire a grounded shot when emerging from the waiting state after a jump.
          } else if (octorok.state === 'waitAfterJump') {
            // Grounded shot
            const mouthSize = 4;
            const mouthX = octorok.x - 2;
            const mouthY = octorok.y + octorok.height / 2 - mouthSize / 2;
            spawnRock(mouthX - 2, mouthY, -2.5, 0);
            // Now wait again before the next jump+shoot
            octorok.state = 'waitAfterShot';
            octorok.stateTimer = 60;
          }
        }
      }
    }

    // Gravity
    octorok.vy += octorok.gravity;
    // Clamp falling speed so gravity does not accelerate forever.
    if (octorok.vy > octorok.maxFall) octorok.vy = octorok.maxFall;

    // Horizontal movement from knockback
    let newX = octorok.x + octorok.vx;
    // Move horizontally only if the destination is not blocked by terrain.
    if (!rectVsWorld(newX, octorok.y, octorok.width, octorok.height)) {
      octorok.x = newX;
    } else {
      octorok.vx = 0;
    }

    // Vertical collision
    let newY = octorok.y + octorok.vy;
    // Apply vertical motion as long as the body is not intersecting the map.
    if (!rectVsWorld(octorok.x, newY, octorok.width, octorok.height)) {
      octorok.y = newY;
      octorok.onGround = false;
    } else {
      // Resolve downward collisions differently from upward collisions.
      if (octorok.vy > 0) {
        // Step the sprite down until touching ground so it lands cleanly.
        while (!rectVsWorld(octorok.x, octorok.y + 1, octorok.width, octorok.height)) {
          octorok.y += 1;
        }
        octorok.onGround = true;
        // When a jump finishes, transition into the waiting state.
        if (octorok.state === 'jump') {
          octorok.state = 'waitAfterJump';
          octorok.stateTimer = 60;
        }
      } else if (octorok.vy < 0) {
        // Step upward until the head clears the ceiling to avoid clipping.
        while (!rectVsWorld(octorok.x, octorok.y - 1, octorok.width, octorok.height)) {
          octorok.y -= 1;
        }
      }
      octorok.vy = 0;
    }

    // Friction on ground for knockback
    // Apply friction only when grounded so knockback tapers off.
    if (octorok.onGround) {
      octorok.vx *= 0.85;
      // Zero-out extremely tiny velocities to avoid jittering.
      if (Math.abs(octorok.vx) < 0.05) octorok.vx = 0;
    }

    const wasHit = octorok.hitTimer > 0;
    // Count down hitstun frames until the enemy recovers.
    if (octorok.hitTimer > 0) {
      octorok.hitTimer--;
    }

    // Shoot a rock at the apex of the jump during the jump phase (no shooting while in hitstun)
    if (octorok.hitTimer === 0 &&
        !octorok.onGround && !octorok.shotThisJump &&
        octorok.prevVy <= 0 && octorok.vy > 0 &&
        octorok.state === 'jump') {
      const mouthSize = 4;
      const mouthX = octorok.x - 2;
      const mouthY = octorok.y + octorok.height / 2 - mouthSize / 2;
      spawnRock(mouthX - 2, mouthY, -2.5, 0);
      octorok.shotThisJump = true;
    }

    // When hitstun ends, reset the pattern
    if (wasHit && octorok.hitTimer === 0) {
      octorok.state = 'waitAfterShot';
      octorok.stateTimer = 60;
      octorok.shotThisJump = false;
    }

    // Tick the idle animation timer every frame so it loops forever.
    octorok.idleAnimTimer++;
    // Advance to the next idle frame once the configured duration elapses.
    if (octorok.idleAnimTimer >= OCTOROK_IDLE_FRAME_DURATION) {
      octorok.idleAnimTimer = 0;
      octorok.idleAnimFrame = (octorok.idleAnimFrame + 1) % 2;
    }
  }

  // Resolve Link's sword strikes and collision responses against a specific octorok.
  function handleOctorokPlayerInteractions(octorok) {
    const sword = swordHitbox();
    // Only damage the enemy when Link is actively stabbing and the octorok is vulnerable.
    if (sword && rectsOverlap(sword, octorok) && octorok.hitTimer === 0) {
      octorok.hitTimer = 10;
      const knockDir = player.facing;
      octorok.vx = 3 * knockDir;
      octorok.vy = -2.5;
    }

    // Evaluate body collisions only when Link is not already recovering from damage.
    if (player.hitTimer === 0) {
      const playerBox = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };
      // Trigger knockback and invulnerability when Link bumps into the enemy.
      if (rectsOverlap(playerBox, octorok)) {
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const enemyCenter = octorok.x + octorok.width / 2;
        const dir = playerCenter < enemyCenter ? -1 : 1;

        // Immediately separate horizontally so we don't stay overlapping.
        // Push Link to the left when he was positioned on that side of the enemy.
        if (dir < 0) {
          player.x = octorok.x - player.width - 1;
        } else {
          player.x = octorok.x + octorok.width + 1;
        }

        player.vx = dir * 3.2;
        player.vy = -4;
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }
  }

  // Advance the Armos Knight's idle, shield, and attack timers.
  function updateArmosKnight(knight) {
    const playerCenter = player.x + player.width / 2;
    const knightCenter = knight.x + knight.width / 2;
    // Face toward Link so the shield and sword always orient correctly.
    knight.facing = playerCenter < knightCenter ? -1 : 1;

    // Count down the brief hit flash timer if the knight was recently struck.
    if (knight.hitTimer > 0) {
      knight.hitTimer--;
    }

    // Apply horizontal knockback velocity while the recoil timer is still active.
    if (knight.knockbackTimer > 0) {
      knight.x += knight.vx;
      knight.vx *= 0.85;
      knight.knockbackTimer--;
    } else if (Math.abs(knight.vx) > 0.01) {
      // Stop any tiny drift that remains once the recoil period ends.
      knight.vx = 0;
    }

    // When the knight is swinging, keep ticking through the attack animation frames.
    if (knight.attacking) {
      knight.attackTimer++;
      // Return to idle once the windup, stab, and recovery have all played out.
      if (knight.attackTimer >= knight.attackDuration) {
        knight.attacking = false;
        knight.attackTimer = 0;
        knight.attackCooldown = 180 + Math.floor(Math.random() * 60);
      }
    } else {
      // Count down the idle cooldown until it is time to launch another strike.
      if (knight.attackCooldown > 0) {
        knight.attackCooldown--;
      }
      // Start a new attack sequence once the cooldown elapses.
      if (knight.attackCooldown <= 0) {
        knight.attacking = true;
        knight.attackTimer = 0;
        knight.attackHeight = Math.random() < 0.5 ? 'high' : 'low';
      }
    }

    // Only consider changing shield positions when Link is not applying pressure.
    if (!player.attacking) {
      knight.shieldChangeTimer++;
      // Every two seconds roll a coin flip to potentially swap the shield height.
      if (knight.shieldChangeTimer >= 120) {
        knight.shieldChangeTimer = 0;
        // Flip the stance roughly half the time to keep Link guessing.
        if (Math.random() < 0.5) {
          knight.shieldHigh = !knight.shieldHigh;
        }
      }
    } else {
      // Reset the timer while Link is mid-attack so the cadence restarts afterward.
      knight.shieldChangeTimer = 0;
    }
  }

  // Build the knight's shield collision box for the current pose so Link's sword can bounce off of it.
  function knightShieldHitbox(knight) {
    const shieldWidth = TILE_SIZE * 0.6;
    const shieldHeight = TILE_SIZE - 2;
    const shieldX = knight.facing > 0
      ? knight.x + knight.width - shieldWidth + 1
      : knight.x - 1;
    const shieldY = knight.shieldHigh
      ? knight.y + 2
      : knight.y + knight.height - shieldHeight;
    return {
      x: shieldX,
      y: shieldY,
      width: shieldWidth,
      height: shieldHeight
    };
  }

  // Determine which segment of the attack animation is currently playing for the knight.
  function knightAttackPhase(knight) {
    if (!knight.attacking) return 'idle';
    const t = knight.attackTimer;
    if (t < knight.attackWindup) return 'windup';
    if (t < knight.attackWindup + knight.attackStab) return 'stab';
    return 'recover';
  }

  // Compute the sword's rectangle for rendering and collision so they always stay in sync.
  function knightSwordPose(knight) {
    const phase = knightAttackPhase(knight);
    if (phase === 'idle') return null;

    const swordWidth = 4;
    let swordLength = TILE_SIZE;
    let forwardAdjust = 0;

    // Gradually pull the sword back during the windup to create a telegraphed motion.
    if (phase === 'windup') {
      const windupProgress = knight.attackWindup === 0
        ? 1
        : knight.attackTimer / knight.attackWindup;
      swordLength = TILE_SIZE * 0.8;
      forwardAdjust = -swordLength * (1 - windupProgress);
    // Ease the sword back toward the body while recovering from a stab.
    } else if (phase === 'recover') {
      const recoverElapsed = knight.attackTimer - (knight.attackWindup + knight.attackStab);
      const recoverDuration = Math.max(1, knight.attackRecover);
      const recoverProgress = Math.min(1, recoverElapsed / recoverDuration);
      swordLength = TILE_SIZE * 0.8;
      forwardAdjust = -swordLength * recoverProgress * 0.8;
    }

    const swordX = knight.facing > 0
      ? knight.x + knight.width + forwardAdjust
      : knight.x - swordLength - forwardAdjust;
    const verticalOffset = knight.attackHeight === 'high'
      ? 4
      : knight.height - TILE_SIZE / 2;
    const swordY = knight.y + verticalOffset - (phase === 'windup' ? 2 : 0);

    return {
      phase,
      rect: {
        x: swordX,
        y: swordY,
        width: swordLength,
        height: swordWidth
      }
    };
  }

  // Create the knight's sword hitbox whenever the attack animation reaches the active stab frames.
  function knightSwordHitbox(knight) {
    const pose = knightSwordPose(knight);
    // Abort when the knight is not currently swinging the sword.
    if (!pose || pose.phase !== 'stab') return null;
    return pose.rect;
  }

  // Evaluate collisions between Link and the Armos Knight, including sword clashes and body bumps.
  function handleArmosKnightVsPlayer(knight) {
    const sword = swordHitbox();
    const knightShield = knightShieldHitbox(knight);
    const playerBox = {
      x: player.x,
      y: player.y,
      width: player.width,
      height: player.height
    };
    // Only attempt to damage the knight when Link is mid-stab and the shield does not intercept the blade.
    if (sword && knight.hitTimer === 0) {
      const swordBlocked = rectsOverlap(sword, knightShield);
      // Only register damage if the blade sneaks around the shield and touches the body.
      if (!swordBlocked && rectsOverlap(sword, knight)) {
        knight.hitTimer = 14;
        const knockDir = player.facing;
        knight.vx = knockDir * 2.5;
        knight.knockbackTimer = 12;
      } else if (swordBlocked && !player.blockedThisSwing) {
        // Recoil Link slightly when the shield successfully blocks the strike.
        const recoilDir = player.facing;
        player.x -= recoilDir * 1.5;
        player.vx = -recoilDir * 2.0;
        player.vy = Math.min(player.vy, -1);
        player.blockedThisSwing = true;
      }
    }

    // Treat the knight like a solid enemy so touching it hurts Link.
    if (player.hitTimer === 0) {
      // Apply damage when Link's hurtbox overlaps the knight's body.
      if (rectsOverlap(playerBox, knight)) {
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const enemyCenter = knight.x + knight.width / 2;
        const dir = playerCenter < enemyCenter ? -1 : 1;

        // Push Link to whichever side he should bounce away toward.
        if (dir < 0) {
          player.x = knight.x - player.width - 1;
        } else {
          player.x = knight.x + knight.width + 1;
        }

        player.vx = dir * 3.2;
        player.vy = -4;
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }

    const knightSword = knightSwordHitbox(knight);
    // Let the knight's sword harm Link when it slips past the hero's shield.
    if (knightSword && player.hitTimer === 0) {
      const shieldBox = shieldHitbox();
      const swordHitsPlayer = rectsOverlap(knightSword, playerBox);
      const shieldBlocksSword = rectsOverlap(knightSword, shieldBox);
      // Hurt Link only when the sword overlaps his body without being blocked by the shield.
      if (swordHitsPlayer && !shieldBlocksSword) {
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const enemyCenter = knight.x + knight.width / 2;
        const dir = playerCenter < enemyCenter ? -1 : 1;
        player.vx = dir * 3.2;
        player.vy = -4;
        player.x += dir * 1.5;
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }
  }

  // Compute the player's shield hitbox, accounting for crouching and facing.
  function shieldHitbox() {
    const shieldWidth = TILE_SIZE * 0.6;
    const shieldHeight = TILE_SIZE;
    let shieldY;
    // Anchor the shield lower while crouching so it covers Link's knees.
    if (player.crouching) {
      shieldY = player.y + player.height - shieldHeight;
    } else {
      shieldY = player.y + TILE_SIZE * 0.2;
    }
    let shieldX;
    // Offset the shield based on facing so it always sits in front of Link.
    if (player.facing > 0) {
      shieldX = player.x + player.width - shieldWidth + 1;
    } else {
      shieldX = player.x - 1;
    }
    return {
      x: shieldX,
      y: shieldY,
      width: shieldWidth,
      height: shieldHeight
    };
  }

  // Move active projectiles and particles while handling their collisions.
  function updateRocksAndParticles() {
    // Rocks
    // Step through each projectile to update its physics and collisions.
    for (const rock of rocks) {
      // Skip rocks that already exploded so they don't keep updating.
      if (!rock.alive) continue;
      rock.x += rock.vx;
      rock.y += rock.vy;

      const rockBox = {
        x: rock.x,
        y: rock.y,
        width: rock.size,
        height: rock.size
      };

      const shieldBox = shieldHitbox();
      const playerBox = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };

      let exploded = false;
      // Shield blocks the rock
      if (rectsOverlap(rockBox, shieldBox)) {
        exploded = true;
      } else if (rectsOverlap(rockBox, playerBox) && player.hitTimer === 0) {
        // Hit the player
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const projCenter = rock.x + rock.size / 2;
        const dir = playerCenter < projCenter ? -1 : 1;
        player.vx = dir * 3.0;
        player.vy = -4;
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
        exploded = true;
      }

      // Offscreen
      // Blow up the projectile if it wanders far outside the current view to keep arrays small.
      const offscreenPadding = TILE_SIZE * 4;
      const viewLeft = cameraX - offscreenPadding;
      const viewRight = cameraX + canvas.width + offscreenPadding;
      const viewTop = -offscreenPadding;
      const viewBottom = canvas.height + offscreenPadding;
      if (rock.x + rock.size < viewLeft || rock.x > viewRight ||
          rock.y + rock.size < viewTop || rock.y > viewBottom) {
        exploded = true;
      }

      // Convert the rock into particles after any collision or despawn event.
      if (exploded) {
        rock.alive = false;
        spawnRockExplosion(rock.x + rock.size / 2, rock.y + rock.size / 2);
      }
    }

    // Compact rocks array
    // Walk the array backwards so splices do not skip entries.
    for (let i = rocks.length - 1; i >= 0; i--) {
      // Remove any rock marked as dead to prevent future updates.
      if (!rocks[i].alive) rocks.splice(i, 1);
    }

    // Particles
    // Update each particle's position and fade over time.
    for (const p of particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.05;
      p.life--;
    }
    // Clean up expired particles from the tail end first.
    for (let i = particles.length - 1; i >= 0; i--) {
      if (particles[i].life <= 0) particles.splice(i, 1);
    }
  }

  // Handle player input, physics, combat, and reactions to damage.
  function updatePlayer() {
    // Horizontal input (used for facing even while attacking)
    let inputDir = 0;
    // Tilt left when A is held down.
    if (keys.a) inputDir -= 1;
    // Tilt right when D is held down.
    if (keys.d) inputDir += 1;

    const lockMovement = (player.attacking && player.onGround) || player.hitTimer > 0;
    const moveX = lockMovement ? 0 : inputDir;

    // Crouch (S) can be used on ground or in air,
    // but you can't change crouch state during an attack
    const wasCrouching = player.crouching;
    // Allow crouch toggles only when not attacking or flinching.
    if (!player.attacking && player.hitTimer === 0) {
      player.crouching = keys.s;
    }

    // Adjust collision box when crouching / standing
    if (player.crouching !== wasCrouching) {
      // Shrink the player's collider whenever crouching begins.
      if (player.crouching) {
        const delta = player.standHeight - player.crouchHeight;
        player.y += delta;
        player.height = player.crouchHeight;
      // Try to return to full height if the crouch is released.
      } else {
        const delta = player.standHeight - player.crouchHeight;
        const newY = player.y - delta;
        // Only stand up if there is room
        if (!rectVsWorld(player.x, newY, player.width, player.standHeight)) {
          player.y = newY;
          player.height = player.standHeight;
        } else {
          // Stay crouched if overhead terrain blocks the stand-up attempt.
          player.crouching = true;
        }
      }
    }

    // Facing direction (ignore zero movement)
    if (inputDir !== 0) {
      player.facing = inputDir > 0 ? 1 : -1;
    }

    // Apply horizontal velocity (no air control damping)
    // During hit-stun, preserve knockback velocity instead of overriding it
    // Only override movement while Link is not recoiling from damage.
    if (player.hitTimer === 0) {
      player.vx = moveX * player.speed;
    }

    // Jump (K)
    // Trigger a jump when K is pressed while grounded and free to move.
    if (keys.k && player.onGround && !player.attacking && player.hitTimer === 0) {
      player.vy = player.jumpSpeed;
      player.onGround = false;
    }

    // Gravity
    player.vy += player.gravity;
    // Prevent falling speed from exceeding the cap.
    if (player.vy > player.maxFall) player.vy = player.maxFall;

    // Horizontal collision
    let newX = player.x + player.vx;
    // Slide freely when the path ahead is clear.
    if (!rectVsWorld(newX, player.y, player.width, player.height)) {
      player.x = newX;
    } else {
      // slide
      // Walk pixel-by-pixel into the wall to land flush without overlapping.
      while (!rectVsWorld(player.x + Math.sign(player.vx), player.y, player.width, player.height)) {
        player.x += Math.sign(player.vx);
      }
      player.vx = 0;
    }

    // Vertical collision
    let newY = player.y + player.vy;
    // Allow freefall whenever the new position is unobstructed.
    if (!rectVsWorld(player.x, newY, player.width, player.height)) {
      player.y = newY;
      player.onGround = false;
    } else {
      // Handle downward impacts differently from upward hits.
      if (player.vy > 0) {
        // Landing on ground
        // Step downward until feet touch the floor to avoid sinking.
        while (!rectVsWorld(player.x, player.y + 1, player.width, player.height)) {
          player.y += 1;
        }
        player.onGround = true;
      } else if (player.vy < 0) {
        // Hitting ceiling
        // Step upward until the head clears to keep the body outside tiles.
        while (!rectVsWorld(player.x, player.y - 1, player.width, player.height)) {
          player.y -= 1;
        }
      }
      player.vy = 0;
    }

    // Attack (J) - standing or crouching allowed
    // Start a new stab when J is pressed and Link is free to act.
    if (keys.j && !player.attacking && player.hitTimer === 0) {
      player.attacking = true;
      player.attackTimer = 0;
      player.blockedThisSwing = false;
    }

    // Count through the attack animation frames.
    if (player.attacking) {
      player.attackTimer++;
      // End the attack when the animation timer completes.
      if (player.attackTimer >= player.attackDuration) {
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }

    // Taper off hurt invulnerability each frame until it hits zero.
    if (player.hitTimer > 0) {
      player.hitTimer--;
    }

    // Determine whether Link is currently walking so the animation can advance.
    const currentlyWalking =
      player.onGround &&
      Math.abs(player.vx) > 0.1 &&
      !player.crouching &&
      player.hitTimer === 0 &&
      !player.attacking;
    player.walking = currentlyWalking;
    // Update the walking animation timer/frame whenever movement is happening.
    if (currentlyWalking) {
      player.walkAnimTimer++;
      // Swap frames every few ticks to create a two-step cycle.
      if (player.walkAnimTimer >= WALK_ANIM_FRAME_DURATION) {
        player.walkAnimTimer = 0;
        player.walkAnimFrame = (player.walkAnimFrame + 1) % 2;
      }
    } else {
      // Reset the walk animation when standing still so it starts from frame 0.
      player.walkAnimTimer = 0;
      player.walkAnimFrame = 0;
    }

  }

  // Render the tile-based ground layout relative to the camera.
  function drawWorld() {
    const startTileX = Math.floor(cameraX / TILE_SIZE);
    const endTileX = Math.floor((cameraX + canvas.width) / TILE_SIZE) + 1;
    // Walk each row in the playfield so we can render any visible tiles.
    for (let y = 0; y < WORLD_ROWS; y++) {
      // Inspect every column that overlaps the current viewport.
      for (let tileX = startTileX; tileX <= endTileX; tileX++) {
        if (tileAtTileCoordinates(tileX, y) === 1) {
          const drawX = tileX * TILE_SIZE - cameraX;
          ctx.fillStyle = '#303060';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = '#505090';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, 4);
        }
      }
    }
  }

  // Draw the octorok enemy with its simple animation cues.
  function drawOctorok(octorok) {
    const x = Math.floor(octorok.x - cameraX);
    const y = Math.floor(octorok.y);
    const w = octorok.width;
    const h = octorok.height;
    // Compute the small bobbing offset used by the idle animation.
    const bobOffset = octorok.idleAnimFrame === 0 ? 0 : 1;
    // Compute how far the tentacles lift to create a two-frame cycle.
    const tentacleLift = octorok.idleAnimFrame === 0 ? 0 : 2;

    // Flash when hit
    if (octorok.hitTimer > 0 && (octorok.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#ff7040';
    }
    ctx.fillRect(x, y + bobOffset, w, h - bobOffset);

    // Simple eyes
    ctx.fillStyle = '#000000';
    // Offset the eyes upward during the lifted frame so the whole sprite moves.
    const eyeY = y + 4 + bobOffset - (octorok.idleAnimFrame === 0 ? 0 : 1);
    ctx.fillRect(x + 3, eyeY, 3, 3);
    ctx.fillRect(x + w - 6, eyeY, 3, 3);

    // Little mouth on its left side
    ctx.fillStyle = '#602020';
    const mouthWidth = 4;
    const mouthHeight = 3;
    const mouthX = x - 1;
    const mouthY = y + h / 2 - mouthHeight / 2 + bobOffset;
    ctx.fillRect(Math.floor(mouthX), Math.floor(mouthY), mouthWidth, mouthHeight);

    // Animated tentacles that alternate height every other frame.
    ctx.fillStyle = '#ff905c';
    const tentacleY = y + h - 3 - tentacleLift + bobOffset;
    ctx.fillRect(x, tentacleY, w, 3);
  }

  // Render the Armos Knight along with its shield and sword indicators.
  function drawArmosKnight(knight) {
    const renderX = Math.floor(knight.x - cameraX);
    const renderY = Math.floor(knight.y);
    const w = knight.width;
    const h = knight.height;

    // Flash white while in hitstun to provide quick feedback.
    if (knight.hitTimer > 0 && (knight.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#a04040';
    }
    ctx.fillRect(renderX, renderY, w, h);

    // Draw a darker trim to hint at armor plating.
    ctx.fillStyle = '#702828';
    ctx.fillRect(renderX, renderY, w, 4);
    ctx.fillRect(renderX, renderY + h - 4, w, 4);

    // Depict the helmet with a lighter band.
    ctx.fillStyle = '#d89060';
    ctx.fillRect(renderX, renderY, w, Math.floor(TILE_SIZE / 2));

    const shield = knightShieldHitbox(knight);
    ctx.fillStyle = '#c4c8d8';
    ctx.fillRect(Math.floor(shield.x - cameraX), Math.floor(shield.y), shield.width, shield.height);
    ctx.fillStyle = '#8a8fa8';
    ctx.fillRect(Math.floor(shield.x - cameraX) + 1, Math.floor(shield.y) + 2, shield.width - 2, shield.height - 4);

    const swordPose = knightSwordPose(knight);
    // Only draw the sword when the animation is active.
    if (swordPose) {
      const { rect, phase } = swordPose;
      const swordScreenX = Math.floor(rect.x - cameraX);
      const swordScreenY = Math.floor(rect.y);
      ctx.fillStyle = phase === 'windup' ? '#ffd480' : '#f0f0f0';
      ctx.fillRect(swordScreenX, swordScreenY, rect.width, rect.height);
      // Add a subtle glow during the windup so players can spot the upcoming strike.
      if (phase === 'windup') {
        ctx.fillStyle = 'rgba(255, 215, 130, 0.35)';
        ctx.fillRect(swordScreenX - 1, swordScreenY - 1, rect.width + 2, rect.height + 2);
      }
      ctx.fillStyle = '#c8a060';
      const hiltX = knight.facing > 0
        ? Math.floor(knight.x + knight.width - cameraX)
        : Math.floor(knight.x - 6 - cameraX);
      ctx.fillRect(hiltX, swordScreenY - 2, 6, 2);
    }
  }

  // Render the player character, including sword and shield.
  function drawPlayer() {
    const renderX = Math.floor(player.x - cameraX);
    const renderY = Math.floor(player.y);

    // Base body color (flash when hit)
    if (player.hitTimer > 0 && (player.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#2f9e44';
    }

    // Body (simple rectangle)
    ctx.fillRect(renderX, renderY, player.width, player.height);

    // Head (top section)
    const headHeight = Math.min(TILE_SIZE, player.height);
    if (player.hitTimer > 0 && (player.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#ffe6a0';
    }
    ctx.fillRect(renderX, renderY, player.width, headHeight);

    // Simple helmet / hair band
    ctx.fillStyle = '#40a040';
    ctx.fillRect(renderX, renderY, player.width, 4);

    // Draw the feet with a tiny two-frame walking cycle.
    const footHeight = 4;
    const footBaseY = Math.floor(player.y + player.height - footHeight);
    const legWidth = Math.floor(player.width / 2);
    // Lift the left leg during the first walk frame.
    const leftLift = player.walking && player.walkAnimFrame === 0 ? 2 : 0;
    // Lift the right leg during the second walk frame.
    const rightLift = player.walking && player.walkAnimFrame === 1 ? 2 : 0;
    ctx.fillStyle = '#1f6e32';
    // Left foot rectangle that raises when the leg lifts.
    ctx.fillRect(renderX, footBaseY - leftLift, legWidth, footHeight);
    // Right foot rectangle that raises during its corresponding frame.
    ctx.fillRect(Math.floor(player.x + legWidth - cameraX), footBaseY - rightLift, player.width - legWidth, footHeight);

    // Shield (position depends on crouch / stand)
    const sBox = shieldHitbox();
    ctx.fillStyle = '#b0c0ff';
    ctx.fillRect(Math.floor(sBox.x - cameraX), Math.floor(sBox.y), sBox.width, sBox.height);
    ctx.fillStyle = '#8090d0';
    ctx.fillRect(Math.floor(sBox.x - cameraX) + 1, Math.floor(sBox.y) + 2, sBox.width - 2, sBox.height - 4);

    // Sword stab
    if (player.attacking) {
      const t = player.attackTimer;
      let phase = 'recover';
      // Treat early frames as the windup phase.
      if (t < player.attackWindup) {
        phase = 'windup';
      // Treat middle frames as the thrusting phase.
      } else if (t < player.attackWindup + player.attackStab) {
        phase = 'stab';
      }

      // Length / offset by phase
      let swordLength = TILE_SIZE;
      let forwardAdjust = 0;
      // Shorten and retract the blade during the windup.
      if (phase === 'windup') {
        swordLength = TILE_SIZE / 2;
        forwardAdjust = -swordLength / 2;
      // Shorten again while recovering to mimic pulling back.
      } else if (phase === 'recover') {
        swordLength = TILE_SIZE / 2;
        forwardAdjust = -swordLength / 4;
      }

      ctx.fillStyle = '#f8f8f8';
      const swordWidth = 4;
      const swordX = player.facing > 0
        ? player.x + player.width + forwardAdjust
        : player.x - swordLength - forwardAdjust;
      // Lower sword when crouching
      // Use the same lifted offset as the hitbox so visuals and logic align.
      const standingSwordYOffset = TILE_SIZE - swordWidth - 2;
      const baseOffset = player.crouching ? player.height - TILE_SIZE / 2 : standingSwordYOffset;
      const swordY = player.y + baseOffset;
      ctx.fillRect(Math.floor(swordX - cameraX), Math.floor(swordY), swordLength, swordWidth);

      // Hilt
      ctx.fillStyle = '#c8a060';
      const hiltX = player.facing > 0
        ? swordX - 3
        : swordX + swordLength - 1;
      ctx.fillRect(Math.floor(hiltX - cameraX), Math.floor(swordY - 2), 6, 2);
    }
  }

  // Main game loop that advances simulation and rendering frames.
  function loop() {
    updatePlayer();
    updateCamera();

    const visibleAreas = getVisibleAreaIndices();
    const activeOctoroks = [];
    const activeKnights = [];
    // Gather the enemies that belong to every area visible in or near the camera.
    for (const areaIndex of visibleAreas) {
      const entities = getAreaEntities(areaIndex);
      // Track the area's octorok if it exists so we can update and render it.
      if (entities.octorok) {
        activeOctoroks.push(entities.octorok);
      }
      // Every area includes an Armos Knight, so store the reference for later use.
      if (entities.armosKnight) {
        activeKnights.push(entities.armosKnight);
      }
    }

    // Update each visible octorok before checking for collisions.
    for (const enemy of activeOctoroks) {
      updateOctorok(enemy);
      handleOctorokPlayerInteractions(enemy);
    }

    // Advance each Armos Knight's AI and resolve its interactions with Link.
    for (const knight of activeKnights) {
      updateArmosKnight(knight);
      handleArmosKnightVsPlayer(knight);
    }

    updateRocksAndParticles();

    // Clear
    ctx.fillStyle = '#202048';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawWorld();
    drawPlayer();

    // Render each active octorok.
    for (const enemy of activeOctoroks) {
      drawOctorok(enemy);
    }

    // Render the knights after the player so their swords overlap correctly.
    for (const knight of activeKnights) {
      drawArmosKnight(knight);
    }

    // Draw rocks
    // Iterate over every active projectile to display it.
    for (const rock of rocks) {
      ctx.fillStyle = '#d0b090';
      ctx.fillRect(Math.floor(rock.x - cameraX), Math.floor(rock.y), rock.size, rock.size);
    }

    // Draw particles
    // Iterate across each particle puff to render the debris cloud.
    for (const p of particles) {
      ctx.fillStyle = 'rgba(255, 220, 160, 0.8)';
      ctx.fillRect(Math.floor(p.x - cameraX), Math.floor(p.y), 2, 2);
    }

    requestAnimationFrame(loop);
  }

  loop();
</script>
</body>
</html>
