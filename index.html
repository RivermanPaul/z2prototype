<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Documentation policy: comment every function, conditional, and loop to describe its role. -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <title>Zelda II HTML5 Prototype</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      user-select: none;
      -webkit-user-select: none;
      min-height: 100vh;
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }
    #game-layout {
      width: 100%;
      max-width: 960px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 24px 16px 48px;
      box-sizing: border-box;
    }
    #game-stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      margin: 0 auto;
      background: #202048;
      max-width: 100%;
      height: auto;
    }
    #info {
      text-align: center;
      margin-top: 8px;
      font-size: 14px;
    }
    #info kbd {
      padding: 1px 4px;
      border-radius: 3px;
      border: 1px solid #555;
      background: #222;
      font-family: monospace;
      font-size: 12px;
    }
    #touch-controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 24px;
      margin: 18px auto 32px;
      max-width: 520px;
      padding: 0 16px;
      user-select: none;
      touch-action: manipulation;
    }
    #touch-controls button {
      width: 64px;
      height: 64px;
      border-radius: 14px;
      border: 2px solid #555;
      background: #1d1d2e;
      color: #eee;
      font-size: 18px;
      font-weight: 600;
      text-transform: uppercase;
      box-shadow: inset 0 2px 0 rgba(255,255,255,0.05);
      transition: transform 0.1s ease, background 0.1s ease;
      user-select: none;
      -webkit-user-select: none;
    }
    #touch-controls button:active,
    #touch-controls button.active {
      background: #353562;
      transform: translateY(2px);
    }
    #touch-controls .dpad {
      display: grid;
      grid-template-columns: repeat(3, 64px);
      grid-template-rows: repeat(3, 64px);
      gap: 8px;
    }
    #touch-controls .dpad button {
      font-size: 20px;
    }
    #touch-controls .dpad button.empty {
      visibility: hidden;
      pointer-events: none;
    }
    #touch-controls .actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #touch-controls .actions button {
      width: 88px;
    }
    @media (max-width: 480px) {
      #touch-controls {
        gap: 16px;
      }
      #touch-controls button {
        width: 56px;
        height: 56px;
      }
      #touch-controls .dpad {
        grid-template-columns: repeat(3, 56px);
        grid-template-rows: repeat(3, 56px);
      }
      #touch-controls .actions button {
        width: 72px;
      }
    }
    .mobile-landscape body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      width: 100vw;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .mobile-landscape #game-layout {
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 32px;
      max-width: none;
      width: 100%;
      height: 100%;
      padding: 0 24px;
      box-sizing: border-box;
    }
    .mobile-landscape #game-stage {
      flex: 1 1 auto;
    }
    .mobile-landscape canvas {
      width: min(calc((100vh - 48px) * 512 / 288), calc(100vw - 220px));
      max-width: none;
      height: auto;
    }
    .mobile-landscape #touch-controls {
      margin: 0;
      flex-direction: column;
      flex-wrap: nowrap;
      gap: 18px;
      max-width: none;
      padding: 0;
    }
    .mobile-landscape #info {
      position: absolute;
      bottom: env(safe-area-inset-bottom, 16px);
      left: 50%;
      transform: translateX(-50%);
      margin-top: 0;
      font-size: 12px;
      opacity: 0.85;
    }
  </style>
</head>
<body>
<div id="game-layout">
  <div id="game-stage">
    <canvas id="game" width="512" height="288"></canvas>
    <div id="info">
      Controls:
      <kbd>W</kbd>/<kbd>A</kbd>/<kbd>S</kbd>/<kbd>D</kbd> move &amp; crouch,
      <kbd>K</kbd> jump,
      <kbd>J</kbd> stab
    </div>
  </div>
  <div id="touch-controls">
    <div class="dpad">
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button data-key="w" aria-label="Up">▲</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button data-key="a" aria-label="Left">◀</button>
      <button data-key="s" aria-label="Down">▼</button>
      <button data-key="d" aria-label="Right">▶</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
    </div>
    <div class="actions">
      <button data-key="j">Stab</button>
      <button data-key="k">Jump</button>
    </div>
  </div>
</div>

<script>
  // Prevent browser UI gestures (scrolling, pinch-zoom, etc.) from interrupting gameplay.
  window.addEventListener('gesturestart', (event) => {
    event.preventDefault();
  });
  // Block scrolling that could be triggered by touchmove events while using on-screen controls.
  window.addEventListener('touchmove', (event) => {
    event.preventDefault();
  }, { passive: false });

  // Basic Zelda II style platformer prototype
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Track whether we are on a small viewport so we can optimize the layout for mobile screens.
  const mobileMediaQuery = window.matchMedia('(max-width: 768px)');

  // Function that toggles a helper class when the layout should stretch to a full-screen landscape view.
  function syncMobileLayoutClass() {
    // Identify when we are both on a mobile-sized viewport and currently in landscape orientation.
    const inLandscapeMobile = mobileMediaQuery.matches && window.matchMedia('(orientation: landscape)').matches;
    // Add the helper class so CSS can drive the full-screen layout in mobile landscape.
    if (inLandscapeMobile) {
      document.documentElement.classList.add('mobile-landscape');
    // Remove the class whenever we leave the mobile landscape configuration.
    } else {
      document.documentElement.classList.remove('mobile-landscape');
    }
  }

  // Ensure the helper class matches the current viewport before the game starts running.
  syncMobileLayoutClass();
  // Update the layout helper class whenever the viewport changes dimensions.
  window.addEventListener('resize', syncMobileLayoutClass);
  window.addEventListener('orientationchange', syncMobileLayoutClass);

  // Attempt to lock the screen orientation to landscape on mobile browsers that support the API for a more immersive view.
  if (mobileMediaQuery.matches && 'orientation' in screen && typeof screen.orientation.lock === 'function') {
    screen.orientation.lock('landscape').catch(() => {});
  }

  // Game mode flags so we can swap between the side-view and overworld engines.
  const GAME_MODE_SIDE_SCROLL = 'side-scroll';
  const GAME_MODE_OVERWORLD = 'overworld';
  const GAME_MODE_RAISED = 'raised';
  let gameMode = GAME_MODE_SIDE_SCROLL;

  // World / tile setup
  const TILE_SIZE = 16;
  const WORLD_ROWS = Math.floor(canvas.height / TILE_SIZE);
  const SCREEN_COLS = Math.floor(canvas.width / TILE_SIZE);
  const AREA_SCREEN_COUNT = 2;
  const AREA_COLS = SCREEN_COLS * AREA_SCREEN_COUNT;
  const AREA_WIDTH = AREA_COLS * TILE_SIZE;
  const TOWN_AREA_COUNT = 2;
  const TOWN_TOTAL_WIDTH = TOWN_AREA_COUNT * AREA_WIDTH;
  const TOWN_GROUND_Z = (WORLD_ROWS - 4) * TILE_SIZE;

  // Cache of generated areas so we only build each layout once.
  const areaCache = new Map();
  // Cache enemy instances per area so we can preserve their state when revisiting rooms.
  const areaEntities = new Map();
  // Track the generated raised-view town layouts so each area only builds once.
  const townAreaCache = new Map();

  // Produce the tile grid for a given area index.
  function generateAreaTiles(areaIndex) {
    const tiles = [];
    // Build the base ground/air layout row-by-row.
    // Iterate over each world row so we can fill in the ground pattern.
    for (let y = 0; y < WORLD_ROWS; y++) {
      const row = [];
      // Populate the row column-by-column so every cell receives either solid ground or air.
      for (let x = 0; x < AREA_COLS; x++) {
        // Keep the bottom two rows solid to act as ground just like the original room.
        if (y === WORLD_ROWS - 2 || y === WORLD_ROWS - 1) {
          row.push(1);
        } else {
          row.push(0);
        }
      }
      tiles.push(row);
    }

    // Add floating platforms. Each step to the right gains one more platform, steps to the
    // left remove one, and the base area starts with a single platform.
    const platformCount = Math.max(0, areaIndex + 1);
    const platformRow = WORLD_ROWS - 6;
    const platformWidth = 6;
    if (platformRow >= 0 && platformCount > 0) {
      const spacing = AREA_COLS / (platformCount + 1);
      // Step through each platform slot so we can drop solid ledges across the span.
      for (let i = 0; i < platformCount; i++) {
        const center = Math.round(spacing * (i + 1));
        const start = Math.max(1, Math.min(AREA_COLS - platformWidth - 1, Math.floor(center - platformWidth / 2)));
        // Fill every tile covered by the platform with solid cells.
        for (let x = start; x < start + platformWidth; x++) {
          tiles[platformRow][x] = 1;
        }
      }
    }

    return tiles;
  }

  // Return (and lazily build) the tile array for the requested area index.
  function getAreaTiles(areaIndex) {
    if (!areaCache.has(areaIndex)) {
      areaCache.set(areaIndex, generateAreaTiles(areaIndex));
    }
    return areaCache.get(areaIndex);
  }

  // Produce the tile grid for a given raised town area index.
  function generateTownAreaTiles(areaIndex) {
    const tiles = [];
    // Build the base plaza layout row-by-row so the ground is mostly walkable.
    for (let y = 0; y < WORLD_ROWS; y++) {
      const row = [];
      // Populate each column of the current row with walkable space by default.
      for (let x = 0; x < AREA_COLS; x++) {
        let value = 0;
        const globalX = areaIndex * AREA_COLS + x;
        // Keep the perimeter walls solid so players stay inside the town bounds.
        if (y === 0 || y === WORLD_ROWS - 1) {
          value = 1;
        }
        row.push(value);
      }
      tiles.push(row);
    }

    // Place a long shopfront along the back edge of the first plaza area.
    if (areaIndex === 0) {
      for (let y = 2; y <= 5; y++) {
        for (let x = 8; x <= 24; x++) {
          // Leave a doorway gap so the front row still looks traversable.
          if (x >= 15 && x <= 17) continue;
          tiles[y][x] = 1;
        }
      }
      // Add a planter stripe to break up the center of the courtyard.
      for (let x = 32; x <= 44; x++) {
        tiles[9][x] = 1;
      }
    }

    // Stagger a pair of warehouses in the second area to form a gentle zig-zag path.
    if (areaIndex === 1) {
      for (let y = 3; y <= 7; y++) {
        for (let x = 6; x <= 16; x++) {
          tiles[y][x] = 1;
        }
      }
      for (let y = 8; y <= 12; y++) {
        for (let x = 38; x <= 54; x++) {
          tiles[y][x] = 1;
        }
      }
    }

    return tiles;
  }

  // Return (and lazily build) the tile array for the requested raised town area index.
  function getTownAreaTiles(areaIndex) {
    if (!townAreaCache.has(areaIndex)) {
      townAreaCache.set(areaIndex, generateTownAreaTiles(areaIndex));
    }
    return townAreaCache.get(areaIndex);
  }

  // Return the list of area indices that overlap the current camera view (with padding for nearby rooms).
  function getVisibleAreaIndices() {
    const start = Math.floor(cameraX / AREA_WIDTH) - 1;
    const end = Math.floor((cameraX + canvas.width) / AREA_WIDTH) + 1;
    const indices = [];
    // Step through each area index that may appear within or near the viewport so we can activate their entities.
    for (let areaIndex = start; areaIndex <= end; areaIndex++) {
      indices.push(areaIndex);
    }
    return indices;
  }

  // Build an octorok instance positioned at the requested world coordinates.
  function createOctorokAt(x, y) {
    return {
      x,
      y,
      width: TILE_SIZE,
      height: TILE_SIZE,
      vx: 0,
      vy: 0,
      gravity: 0.30,
      maxFall: 8,
      onGround: false,
      jumpSpeed: -3.4,
      hitTimer: 0,
      prevVy: 0,
      shotThisJump: false,
      state: 'waitAfterShot',
      stateTimer: 120,
      idleAnimTimer: 0,
      idleAnimFrame: 0
    };
  }

  // Create an Armos Knight that stands at the requested world coordinates.
  function createArmosKnightAt(x, y) {
    return {
      x,
      y,
      width: TILE_SIZE,
      height: TILE_SIZE * 2,
      vx: 0,
      facing: -1,
      attacking: false,
      attackTimer: 0,
      attackWindup: 30,
      attackStab: 12,
      attackRecover: 18,
      attackCooldown: 180 + Math.floor(Math.random() * 60),
      attackHeight: 'high',
      hitTimer: 0,
      shieldHigh: true,
      shieldChangeTimer: 0,
      knockbackTimer: 0,
      // Track whether the current sword swing already bounced off Link's shield.
      blockedThisSwing: false,
      // Distance control helpers so the knight can shuffle around Link.
      desiredRange: TILE_SIZE * 1.6,
      shuffleAmplitude: TILE_SIZE * 0.4,
      shufflePeriod: 150,
      engageRange: TILE_SIZE * 6,
      walkSpeed: 0.9,
      walkResponsiveness: 0.05,
      walkTimer: 0,
      walkTargetX: x,
      walking: false,
      walkAnimTimer: 0,
      walkAnimFrame: 0,
      lastWalkStep: 0,
      get attackDuration() {
        return this.attackWindup + this.attackStab + this.attackRecover;
      }
    };
  }

  // Locate a suitable platform within the requested area so the resident octorok can perch on it.
  function findOctorokSpawn(areaIndex, areaTiles) {
    const platformRow = WORLD_ROWS - 6;
    // Abort when the configured platform row falls outside the world height.
    if (platformRow < 0 || platformRow >= WORLD_ROWS) return null;
    const spans = [];
    let spanStart = -1;
    // Scan the entire row to collect contiguous stretches of solid tiles that represent platforms.
    for (let x = 0; x < AREA_COLS; x++) {
      // Begin tracking a new platform span whenever a floating solid tile appears after empty space.
      if (areaTiles[platformRow][x] === 1 && areaTiles[platformRow + 1][x] === 0) {
        // Start the span at the current column if we are not already tracking one.
        if (spanStart === -1) {
          spanStart = x;
        }
      // Close out the span as soon as we return to air tiles.
      } else if (spanStart !== -1) {
        spans.push({ start: spanStart, end: x - 1 });
        spanStart = -1;
      }
    }
    // Ensure the trailing platform is recorded if the row ends on a solid tile.
    if (spanStart !== -1) {
      spans.push({ start: spanStart, end: AREA_COLS - 1 });
    }
    // Skip spawning if the area has no floating platforms.
    if (spans.length === 0) return null;
    const targetCenter = AREA_COLS / 2;
    let bestSpan = spans[0];
    let smallestDistance = Infinity;
    // Choose the platform whose center sits closest to the area's midpoint so the fight feels balanced.
    for (const span of spans) {
      // Measure how far the current span is from the center so we can keep the closest one.
      const center = (span.start + span.end + 1) / 2;
      const distance = Math.abs(center - targetCenter);
      // Keep whichever span minimizes the distance to the center to reduce travel time.
      if (distance < smallestDistance) {
        smallestDistance = distance;
        bestSpan = span;
      }
    }
    const centerTile = (bestSpan.start + bestSpan.end + 1) / 2;
    const spawnX = areaIndex * AREA_WIDTH + centerTile * TILE_SIZE - TILE_SIZE / 2;
    const spawnY = platformRow * TILE_SIZE - TILE_SIZE;
    return { x: spawnX, y: spawnY };
  }

  // Lazily generate the persistent enemy set that belongs to a specific area index.
  function getAreaEntities(areaIndex) {
    // Build the area's enemies the first time we request them so they persist afterward.
    if (!areaEntities.has(areaIndex)) {
      const tiles = getAreaTiles(areaIndex);
      const spawn = findOctorokSpawn(areaIndex, tiles);
      const octorok = spawn ? createOctorokAt(spawn.x, spawn.y) : null;
      const groundY = (WORLD_ROWS - 2) * TILE_SIZE - TILE_SIZE * 2;
      const knightX = areaIndex * AREA_WIDTH + AREA_WIDTH / 2 - TILE_SIZE / 2;
      const armosKnight = createArmosKnightAt(knightX, groundY);
      areaEntities.set(areaIndex, { octorok, armosKnight });
    }
    return areaEntities.get(areaIndex);
  }

  // Track the current horizontal scroll position of the camera.
  let cameraX = 0;

  // Update the camera so it stays centered on Link while remaining inside the active area.
  function updateCamera() {
    const areaIndex = Math.floor(player.x / AREA_WIDTH);
    const areaStart = areaIndex * AREA_WIDTH;
    const areaEnd = areaStart + AREA_WIDTH;
    const target = player.x + player.width / 2 - canvas.width / 2;
    const minCam = areaStart;
    const maxCam = areaEnd - canvas.width;
    cameraX = Math.min(Math.max(target, minCam), maxCam);
  }

  // Update the raised-view camera so it follows Link across the fixed-length town strip.
  function updateTownCamera() {
    const target = player.x + player.width / 2 - canvas.width / 2;
    const minCam = 0;
    const maxCam = Math.max(0, TOWN_TOTAL_WIDTH - canvas.width);
    cameraX = Math.min(Math.max(target, minCam), maxCam);
  }

  // Duration of the player's walking animation frames in ticks.
  const WALK_ANIM_FRAME_DURATION = 6;
  // Duration of the Octorok's idle animation frames in ticks.
  const OCTOROK_IDLE_FRAME_DURATION = 24;

  // Player properties: 2 tiles tall, 1 tile wide
  const player = {
    x: 4 * TILE_SIZE,
    y: (WORLD_ROWS - 4) * TILE_SIZE,
    z: (WORLD_ROWS - 4) * TILE_SIZE,
    width: TILE_SIZE,
    height: TILE_SIZE * 2,
    standHeight: TILE_SIZE * 2,
    crouchHeight: Math.floor(TILE_SIZE * 1.75),
    vx: 0,
    vy: 0,
    speed: 2.2,
    jumpSpeed: -7,
    gravity: 0.35,
    maxFall: 10,
    onGround: false,
    facing: 1, // 1 right, -1 left
    crouching: false,
    attacking: false,
    attackTimer: 0,
    hitTimer: 0,
    attackWindup: 2,
    attackStab: 6,
    attackRecover: 3,
    blockedThisSwing: false,
    walking: false,
    walkAnimTimer: 0,
    walkAnimFrame: 0,
    get attackDuration() {
      return this.attackWindup + this.attackStab + this.attackRecover;
    }
  };

  // Define the top-down overworld tile grid so moving left of the starting room switches engines.
  const overworldLayout = [
    'MMMMMMMMMMMMMMMMMMM',
    'MGGGGGGGGGGGGGGGGGM',
    'MGGGGGGGGGGGGGGGGGM',
    'MGGGGGWWWGGGGGGGGGM',
    'MGGTTWWWWWGGGGGGGGM',
    'MGGTTPPWWWPPPGGGGGM',
    'MGGGPPPWWWPPPGGGGGP',
    'MGGGGWWWWWGGGGGGGGM',
    'MGGGGGWWWGGGGGGGGGM',
    'MGGGGGGGGGGGGGGGGGM',
    'MGGGGGGGGGGGGGGGGGM',
    'MMMMMMMMMMMMMMMMMMM'
  ];

  // Track overworld state independently from the side-scrolling engine.
  const overworldState = {
    tileSize: TILE_SIZE,
    map: overworldLayout,
    width: overworldLayout[0].length,
    height: overworldLayout.length,
    playerTileX: overworldLayout[0].length - 2,
    playerTileY: 6,
    moving: false,
    moveFrom: { x: 0, y: 0 },
    moveTo: { x: 0, y: 0 },
    moveTimer: 0,
    moveDuration: 8,
    facing: 'left',
    pendingTileInteraction: false
  };

  // Precompute the overworld tiles that represent the town entrance so we can map exits back to each side.
  const townEntranceTiles = (() => {
    const tiles = [];
    // Walk each overworld row to collect every tile that belongs to the town footprint.
    for (let y = 0; y < overworldLayout.length; y++) {
      const row = overworldLayout[y];
      // Step across each column in the current row so we can detect town markers.
      for (let x = 0; x < row.length; x++) {
        if (row[x] === 'T') {
          tiles.push({ x, y });
        }
      }
    }
    // Handle the edge case where no town tiles exist by returning empty sides.
    if (tiles.length === 0) return { left: [], right: [] };
    const minX = Math.min(...tiles.map((t) => t.x));
    const maxX = Math.max(...tiles.map((t) => t.x));
    return {
      left: tiles.filter((t) => t.x === minX),
      right: tiles.filter((t) => t.x === maxX)
    };
  })();

  // Choose the entrance tile on the requested side that is closest to the provided row.
  function closestTownEntrance(side, targetY) {
    const candidates = side === 'right' ? townEntranceTiles.right : townEntranceTiles.left;
    // Skip selection entirely when no candidate tiles exist on that side.
    if (candidates.length === 0) return null;
    let best = candidates[0];
    let bestDistance = Math.abs(best.y - targetY);
    // Walk through every candidate tile so we can locate the nearest matching row.
    for (const tile of candidates) {
      const distance = Math.abs(tile.y - targetY);
      // Keep whichever tile has the smallest distance to the target row.
      if (distance < bestDistance) {
        best = tile;
        bestDistance = distance;
      }
    }
    return best;
  }

  // Track contextual data for the raised-view town, including where to return on exit.
  const townState = {
    entryTile: { x: overworldLayout[0].length - 2, y: 6 },
    entrySide: 'left'
  };

  // Reset Link's side-view pose when returning from the overworld.
  function resetSideViewPlayerPosition() {
    player.x = TILE_SIZE * 2;
    player.y = (WORLD_ROWS - 4) * TILE_SIZE;
    player.z = player.y;
    player.vx = 0;
    player.vy = 0;
    player.onGround = true;
    player.attacking = false;
    player.attackTimer = 0;
    player.blockedThisSwing = false;
    player.crouching = false;
    player.height = player.standHeight;
    cameraX = 0;
    lastAttackPressed = false;
    lastJumpPressed = false;
  }

  // Place Link at the front of the raised-view town while clearing any combat state.
  function resetTownPlayerPosition() {
    player.x = townState.entrySide === 'right'
      ? TOWN_TOTAL_WIDTH - TILE_SIZE * 3
      : TILE_SIZE * 2;
    player.y = TOWN_GROUND_Z;
    player.z = TOWN_GROUND_Z;
    player.vx = 0;
    player.vy = 0;
    player.onGround = true;
    player.attacking = false;
    player.attackTimer = 0;
    player.blockedThisSwing = false;
    player.crouching = false;
    player.height = player.standHeight;
    player.facing = townState.entrySide === 'right' ? -1 : 1;
    cameraX = 0;
    lastAttackPressed = false;
    lastJumpPressed = false;
  }

  // Enter the overworld when Link exits the starting room to the left.
  function enterOverworldFromSideView() {
    gameMode = GAME_MODE_OVERWORLD;
    overworldState.playerTileX = overworldState.width - 2;
    overworldState.playerTileY = 6;
    overworldState.moving = false;
    overworldState.moveTimer = 0;
    overworldState.facing = 'left';
    overworldState.pendingTileInteraction = false;
  }

  // Return to the side-scrolling engine after walking back to the right edge of the overworld.
  function returnToSideScrollFromOverworld() {
    gameMode = GAME_MODE_SIDE_SCROLL;
    resetSideViewPlayerPosition();
  }

  // Enter the raised-view town scene and remember which overworld tile to return to.
  function enterTownFromOverworld() {
    gameMode = GAME_MODE_RAISED;
    townState.entryTile = { x: overworldState.playerTileX, y: overworldState.playerTileY };
    // Decide whether this entry came from the left or right side so exits can mirror it.
    const nearestLeft = closestTownEntrance('left', townState.entryTile.y);
    const nearestRight = closestTownEntrance('right', townState.entryTile.y);
    const distanceToLeft = nearestLeft ? Math.abs(nearestLeft.x - townState.entryTile.x) : Infinity;
    const distanceToRight = nearestRight ? Math.abs(nearestRight.x - townState.entryTile.x) : Infinity;
    townState.entrySide = distanceToRight < distanceToLeft ? 'right' : 'left';
    resetTownPlayerPosition();
  }

  // Return to the overworld from town by restoring the saved tile coordinates.
  function returnToOverworldFromTown(exitSide = townState.entrySide) {
    gameMode = GAME_MODE_OVERWORLD;
    const destination = closestTownEntrance(exitSide, townState.entryTile.y) || townState.entryTile;
    overworldState.playerTileX = destination.x;
    overworldState.playerTileY = destination.y;
    overworldState.moving = false;
    overworldState.moveTimer = 0;
    overworldState.pendingTileInteraction = false;
    overworldState.facing = exitSide === 'right' ? 'right' : 'left';
  }

  const rocks = [];
  const particles = [];

  // Input
  const keys = {
    w: false,
    a: false,
    s: false,
    d: false,
    j: false,
    k: false
  };

  const activePointers = new Map();

  // Track whether the attack input was pressed on the previous frame so we can detect single presses.
  let lastAttackPressed = false;
  // Track whether the jump input was pressed on the previous frame so we only trigger a jump on the edge.
  let lastJumpPressed = false;

  // Release buttons that still track a pointer id or clear a specific button entirely.
  function releasePointerFromButtons(pointerId, specificButton) {
    // Iterate over each button that still has one or more active pointers.
    for (const [btn, set] of activePointers.entries()) {
      // Skip buttons that don't match the requested target.
      if (specificButton && btn !== specificButton) continue;
      // Skip buttons that do not contain the pointer we are clearing.
      if (pointerId !== undefined && !set.has(pointerId)) continue;

      // Drop the specific pointer id or clear the entire button when no id is provided.
      if (pointerId !== undefined) {
        set.delete(pointerId);
      } else {
        set.clear();
      }

      // Release the button entirely once no pointers remain associated with it.
      if (set.size === 0) {
        activePointers.delete(btn);
        setKeyState(btn.dataset.key, false);
        btn.classList.remove('active');
      }

      // Exit early after clearing a matching button or pointer id to avoid extra work.
      if (specificButton || pointerId !== undefined) break;
    }
  }

  // Update the stored pressed state for a given virtual key.
  function setKeyState(key, pressed) {
    // Only update keys that are actually tracked to ignore stray inputs.
    if (key in keys) {
      keys[key] = pressed;
    }
  }

  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    // Only react to keys that are part of the control scheme.
    if (k in keys) {
      keys[k] = true;
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    // Only react to keys that are part of the control scheme.
    if (k in keys) {
      keys[k] = false;
      e.preventDefault();
    }
  });

  // Track the most recently used gamepad so we can poll it each frame.
  const gamepadState = {
    activeIndex: null,
    lastId: '',
    deadZone: 0.2,
    hasConnected: false
  };

  // Log basic information whenever a new gamepad connects so mappings can be verified.
  window.addEventListener('gamepadconnected', (e) => {
    const gp = e.gamepad;
    console.log(
      'Gamepad connected at index %d: %s. %d buttons, %d axes.',
      gp.index,
      gp.id,
      gp.buttons.length,
      gp.axes.length
    );
    console.log('Gamepad mapping:', gp.mapping || '(none)');
    gamepadState.activeIndex = gp.index;
    gamepadState.lastId = gp.id || '';
    gamepadState.hasConnected = true;
  });

  // Clear the active index and log a message whenever a gamepad disconnects.
  window.addEventListener('gamepaddisconnected', (e) => {
    const gp = e.gamepad;
    console.log(
      'Gamepad disconnected from index %d: %s',
      gp.index,
      gp.id
    );
    if (gamepadState.activeIndex === gp.index) {
      gamepadState.activeIndex = null;
    }
  });

  // Show a gentle hint if no controller is detected shortly after the game starts.
  const infoElement = document.getElementById('info');
  if (infoElement) {
    setTimeout(() => {
      // Only display the controller hint when no gamepad has ever connected.
      if (!gamepadState.hasConnected) {
        const hint = document.createElement('div');
        hint.textContent = 'Connect a controller or use touch/keyboard.';
        infoElement.appendChild(hint);
      }
    }, 3000);
  }

  // Read the primary gamepad and convert its raw axes/buttons into high-level actions.
  function readGamepadActions() {
    // Abort if the Gamepad API is not available in this browser.
    if (typeof navigator === 'undefined' || typeof navigator.getGamepads !== 'function') {
      return null;
    }

    const gamepads = navigator.getGamepads();
    if (!gamepads) return null;

    let gp = null;

    // Prefer the last active gamepad index while it remains connected.
    if (gamepadState.activeIndex !== null && gamepads[gamepadState.activeIndex]) {
      gp = gamepads[gamepadState.activeIndex];
    }

    // Fallback: scan for the first non-null gamepad slot.
    if (!gp) {
      for (let i = 0; i < gamepads.length; i++) {
        // Skip empty entries so we only consider attached controllers.
        if (gamepads[i]) {
          gp = gamepads[i];
          break;
        }
      }
    }

    // Abort when no connected gamepads are present.
    if (!gp) return null;

    gamepadState.activeIndex = gp.index;
    gamepadState.lastId = gp.id || gamepadState.lastId;
    gamepadState.hasConnected = true;

    const axes = gp.axes || [];
    const buttons = gp.buttons || [];
    const deadZone = gamepadState.deadZone;

    const lx = axes[0] || 0;
    const ly = axes[1] || 0;

    // Suppress minor stick noise so tiny drift does not cause unintended movement.
    const filteredLX = Math.abs(lx) < deadZone ? 0 : lx;
    const filteredLY = Math.abs(ly) < deadZone ? 0 : ly;

    let left = filteredLX < -0.4;
    let right = filteredLX > 0.4;
    let down = filteredLY > 0.4;

    // Blend in d-pad input so digital presses can move and crouch.
    if (buttons[14] && buttons[14].pressed) left = true;
    if (buttons[15] && buttons[15].pressed) right = true;
    if (buttons[13] && buttons[13].pressed) down = true;

    const btnA = buttons[0] && buttons[0].pressed;
    const btnB = buttons[1] && buttons[1].pressed;
    const btnX = buttons[2] && buttons[2].pressed;

    // Map the south face button (A on Xbox / 8BitDo in X-Input mode) to jump.
    const jump = !!btnA;
    // Map X / B style buttons to sword attacks so either face button can strike.
    const attack = !!(btnX || btnB);

    return { left, right, down, jump, attack };
  }

  // Merge keyboard, touch, and gamepad sources into a single virtual key set for gameplay.
  function combinedInputKeys() {
    const pad = readGamepadActions();
    // When no controller is present, fall back to the raw keyboard/touch state.
    if (!pad) {
      return keys;
    }
    return {
      a: keys.a || pad.left,
      d: keys.d || pad.right,
      s: keys.s || pad.down,
      j: keys.j || pad.attack,
      k: keys.k || pad.jump
    };
  }

  const touchControls = document.getElementById('touch-controls');
  // Only enable touch controls if the UI is present.
  if (touchControls) {
    const buttons = touchControls.querySelectorAll('button[data-key]');
    // Iterate over every virtual button so they all receive pointer handlers.
    buttons.forEach((btn) => {
      const key = btn.dataset.key;
      const getPointerSet = () => {
        let set = activePointers.get(btn);
        if (!set) {
          set = new Set();
          activePointers.set(btn, set);
        }
        return set;
      };

      const press = (e) => {
        e.preventDefault();
        btn.setPointerCapture(e.pointerId);
        const set = getPointerSet();
        if (set.has(e.pointerId)) return;
        const wasInactive = set.size === 0;
        set.add(e.pointerId);
        if (wasInactive) {
          setKeyState(key, true);
          btn.classList.add('active');
        }
      };

      const release = (e) => {
        // Guard against synthetic releases without a pointer event object.
        if (e) e.preventDefault();
        releasePointerFromButtons(e ? e.pointerId : undefined, btn);
      };

      btn.addEventListener('pointerdown', press);
      btn.addEventListener('pointerup', release);
      btn.addEventListener('pointercancel', release);
    });
    // Ensure keys release if pointer leaves the browser viewport entirely.
    window.addEventListener('pointerup', (e) => {
      // Release whichever button was tracking this pointer id.
      releasePointerFromButtons(e.pointerId);
    });
    window.addEventListener('pointercancel', (e) => {
      // Release any button associated with a cancelled pointer gesture.
      releasePointerFromButtons(e.pointerId);
    });
    window.addEventListener('blur', () => {
      // Clear every button when the tab loses focus to avoid stuck inputs.
      releasePointerFromButtons();
    });
  }

  // Determine whether an overworld tile is passable based on its symbol.
  function overworldTileWalkable(tileChar) {
    return tileChar === 'G' || tileChar === 'P' || tileChar === 'T';
  }

  // Retrieve the tile character at the requested overworld coordinate, defaulting to mountains when out of bounds.
  function overworldTileAt(x, y) {
    if (y < 0 || y >= overworldState.height || x < 0 || x >= overworldState.width) {
      return 'M';
    }
    return overworldState.map[y][x];
  }

  // Handle tile-based overworld movement using discrete steps between grid cells.
  function updateOverworld() {
    const inputKeys = combinedInputKeys();

    // Advance any in-progress movement so Link smoothly glides between tiles.
    if (overworldState.moving) {
      overworldState.moveTimer++;
      // Stop stepping once the move timer reaches the configured duration.
      if (overworldState.moveTimer >= overworldState.moveDuration) {
        overworldState.playerTileX = overworldState.moveTo.x;
        overworldState.playerTileY = overworldState.moveTo.y;
        overworldState.moving = false;
        overworldState.moveTimer = 0;
        overworldState.pendingTileInteraction = true;
        // Transition back to the side-view once the player walks off the right edge bridge.
        if (overworldState.playerTileX >= overworldState.width - 1 && overworldState.facing === 'right') {
          returnToSideScrollFromOverworld();
        }
      }
      return;
    }

    // Trigger tile interactions only once after finishing a step to avoid immediate re-entry loops.
    if (overworldState.pendingTileInteraction) {
      overworldState.pendingTileInteraction = false;
      const landedTile = overworldTileAt(overworldState.playerTileX, overworldState.playerTileY);
      // Enter the raised-view town whenever Link steps onto the white plaza tile.
      if (landedTile === 'T') {
        enterTownFromOverworld();
        return;
      }
    }

    // Build an ordered list of desired movement directions so only one tile move occurs per step.
    const desiredMoves = [];
    // Honor upward input by queuing a move to the north tile.
    if (inputKeys.w) desiredMoves.push({ dx: 0, dy: -1, facing: 'up' });
    // Honor downward input by queuing a move to the south tile.
    if (inputKeys.s) desiredMoves.push({ dx: 0, dy: 1, facing: 'down' });
    // Honor leftward input by queuing a move to the west tile.
    if (inputKeys.a) desiredMoves.push({ dx: -1, dy: 0, facing: 'left' });
    // Honor rightward input by queuing a move to the east tile.
    if (inputKeys.d) desiredMoves.push({ dx: 1, dy: 0, facing: 'right' });

    // Attempt the first requested direction to keep controls predictable.
    for (const move of desiredMoves) {
      const targetX = overworldState.playerTileX + move.dx;
      const targetY = overworldState.playerTileY + move.dy;
      const targetTile = overworldTileAt(targetX, targetY);
      // Start a new tile step only when the destination is walkable.
      if (overworldTileWalkable(targetTile)) {
        overworldState.facing = move.facing;
        overworldState.moving = true;
        overworldState.moveFrom = { x: overworldState.playerTileX, y: overworldState.playerTileY };
        overworldState.moveTo = { x: targetX, y: targetY };
        overworldState.moveTimer = 0;
        break;
      }
    }
  }

  // Render the overworld top-down map using simple color-coded tiles.
  function drawOverworld() {
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Loop through each tile to paint the landscape.
    for (let y = 0; y < overworldState.height; y++) {
      // Walk every column of the current row to lay down its tile color.
      for (let x = 0; x < overworldState.width; x++) {
        const tile = overworldState.map[y][x];
        const px = x * overworldState.tileSize + TILE_SIZE * 2;
        const py = y * overworldState.tileSize + TILE_SIZE * 2;
        // Choose a fill color that matches the tile's terrain type.
        if (tile === 'G') {
          ctx.fillStyle = '#7bb858';
        } else if (tile === 'P') {
          ctx.fillStyle = '#d7c06a';
        } else if (tile === 'W') {
          ctx.fillStyle = '#4a6cff';
        } else if (tile === 'T') {
          ctx.fillStyle = '#e6e6e6';
        } else {
          ctx.fillStyle = '#8c5a32';
        }
        ctx.fillRect(px, py, overworldState.tileSize, overworldState.tileSize);
        // Add a darker outline to water and temple tiles for clarity.
        if (tile === 'W' || tile === 'T') {
          ctx.strokeStyle = tile === 'W' ? '#2e3d8f' : '#a8a8a8';
          ctx.strokeRect(px + 0.5, py + 0.5, overworldState.tileSize - 1, overworldState.tileSize - 1);
        }
      }
    }

    // Draw the destination temple so it stands out above the base tile color.
    const templeX = 3 * overworldState.tileSize + TILE_SIZE * 2;
    const templeY = 4 * overworldState.tileSize + TILE_SIZE * 2;
    ctx.fillStyle = '#f4f4f4';
    ctx.fillRect(templeX + 4, templeY + 2, overworldState.tileSize - 8, overworldState.tileSize - 4);
    ctx.fillStyle = '#808080';
    ctx.fillRect(templeX + 6, templeY + 6, overworldState.tileSize - 12, overworldState.tileSize - 10);

    // Compute the player's interpolated position while stepping between tiles.
    const progress = overworldState.moving
      ? Math.min(1, overworldState.moveTimer / overworldState.moveDuration)
      : 0;
    const baseX = overworldState.playerTileX * overworldState.tileSize;
    const baseY = overworldState.playerTileY * overworldState.tileSize;
    const targetOffsetX = overworldState.moving
      ? (overworldState.moveTo.x - overworldState.moveFrom.x) * overworldState.tileSize
      : 0;
    const targetOffsetY = overworldState.moving
      ? (overworldState.moveTo.y - overworldState.moveFrom.y) * overworldState.tileSize
      : 0;
    const playerDrawX = TILE_SIZE * 2 + baseX + targetOffsetX * progress;
    const playerDrawY = TILE_SIZE * 2 + baseY + targetOffsetY * progress;

    // Render Link as a tiny adventurer sprite with a directional arrow to hint at facing.
    ctx.fillStyle = '#2f9e44';
    ctx.fillRect(playerDrawX + 4, playerDrawY + 4, overworldState.tileSize - 8, overworldState.tileSize - 8);
    ctx.fillStyle = '#ffe6a0';
    ctx.fillRect(playerDrawX + 6, playerDrawY + 6, overworldState.tileSize - 12, overworldState.tileSize - 12);
    ctx.fillStyle = '#ffffff';
    // Point a small notch toward the direction Link last walked to echo the NES-style pointer.
    if (overworldState.facing === 'left') {
      ctx.fillRect(playerDrawX + 2, playerDrawY + overworldState.tileSize / 2 - 1, 4, 2);
    } else if (overworldState.facing === 'right') {
      ctx.fillRect(playerDrawX + overworldState.tileSize - 6, playerDrawY + overworldState.tileSize / 2 - 1, 4, 2);
    } else if (overworldState.facing === 'up') {
      ctx.fillRect(playerDrawX + overworldState.tileSize / 2 - 1, playerDrawY + 2, 2, 4);
    } else {
      ctx.fillRect(playerDrawX + overworldState.tileSize / 2 - 1, playerDrawY + overworldState.tileSize - 6, 2, 4);
    }
  }

  // Look up the tile index inside the raised-view town at the requested tile coordinate.
  function townTileAtTileCoordinates(tileX, tileY) {
    // Treat vertical out-of-bounds as solid so Link cannot leave the plaza height.
    if (tileY < 0 || tileY >= WORLD_ROWS) return 1;
    const areaIndex = Math.floor(tileX / AREA_COLS);
    // Treat positions outside the fixed-length town as solid walls.
    if (areaIndex < 0 || areaIndex >= TOWN_AREA_COUNT) return 1;
    const localTileX = tileX - areaIndex * AREA_COLS;
    const areaTiles = getTownAreaTiles(areaIndex);
    return areaTiles[tileY][localTileX];
  }

  // Look up the tile index inside the raised-view town at the requested pixel coordinate.
  function townTileAtPixel(x, y) {
    const tx = Math.floor(x / TILE_SIZE);
    const ty = Math.floor(y / TILE_SIZE);
    return townTileAtTileCoordinates(tx, ty);
  }

  // Look up the tile index that occupies the given tile coordinate across any area.
  function tileAtTileCoordinates(tileX, tileY) {
    if (tileY < 0 || tileY >= WORLD_ROWS) return 1;
    const areaIndex = Math.floor(tileX / AREA_COLS);
    const localTileX = tileX - areaIndex * AREA_COLS;
    const areaTiles = getAreaTiles(areaIndex);
    if (localTileX < 0 || localTileX >= AREA_COLS) return 1;
    return areaTiles[tileY][localTileX];
  }

  // Look up the tile index that occupies the given pixel coordinate.
  function tileAtPixel(x, y) {
    const tx = Math.floor(x / TILE_SIZE);
    const ty = Math.floor(y / TILE_SIZE);
    return tileAtTileCoordinates(tx, ty);
  }

  // Determine whether a rectangle collides with any solid world tiles.
  function rectVsWorld(x, y, width, height) {
    // Check multiple points along the edges so we don't slip into tiles from the side
    const left = x;
    const right = x + width;
    const top = y;
    const bottom = y + height;
    const midY = (top + bottom) / 2;

    // Abort when the top-left corner hits something solid.
    if (tileAtPixel(left, top)) return true;
    // Abort when the top-right corner hits something solid.
    if (tileAtPixel(right - 1, top)) return true;
    // Abort when the mid-left sample hits something solid.
    if (tileAtPixel(left, midY)) return true;
    // Abort when the mid-right sample hits something solid.
    if (tileAtPixel(right - 1, midY)) return true;
    // Abort when the bottom-left corner hits something solid.
    if (tileAtPixel(left, bottom - 1)) return true;
    // Abort when the bottom-right corner hits something solid.
    if (tileAtPixel(right - 1, bottom - 1)) return true;
    return false;
  }

  // Determine whether a rectangle collides with any solid town tiles.
  function townRectVsWorld(x, z, width, height) {
    const left = x;
    const right = x + width;
    const top = z;
    const bottom = z + height;
    const midZ = (top + bottom) / 2;

    // Abort when the top-left corner hits something solid.
    if (townTileAtPixel(left, top)) return true;
    // Abort when the top-right corner hits something solid.
    if (townTileAtPixel(right - 1, top)) return true;
    // Abort when the mid-left sample hits something solid.
    if (townTileAtPixel(left, midZ)) return true;
    // Abort when the mid-right sample hits something solid.
    if (townTileAtPixel(right - 1, midZ)) return true;
    // Abort when the bottom-left corner hits something solid.
    if (townTileAtPixel(left, bottom - 1)) return true;
    // Abort when the bottom-right corner hits something solid.
    if (townTileAtPixel(right - 1, bottom - 1)) return true;
    return false;
  }

  // Build the sword's collision box when Link is in the stab phase of his attack.
  function swordHitbox() {
    // Skip collision while no attack is in progress.
    if (!player.attacking) return null;
    const t = player.attackTimer;
    // Only show the sword hitbox during the active stab frames.
    if (t < player.attackWindup || t >= player.attackWindup + player.attackStab) return null;

    // Match the main stab phase sword position roughly
    const swordLength = TILE_SIZE;
    const swordWidth = 4;
    const x = player.facing > 0 ? player.x + player.width : player.x - swordLength;
    // Lift the standing stab slightly so it can clear low shields.
    const standingSwordYOffset = TILE_SIZE - swordWidth - 2;
    const baseOffset = player.crouching ? player.height - TILE_SIZE / 2 : standingSwordYOffset;
    const y = player.y + baseOffset;
    return { x, y, width: swordLength, height: swordWidth };
  }

  // Perform a simple AABB overlap check.
  function rectsOverlap(a, b) {
    return !(
      a.x + a.width <= b.x ||
      a.x >= b.x + b.width ||
      a.y + a.height <= b.y ||
      a.y >= b.y + b.height
    );
  }

  // Create a new octorok projectile and add it to the active list.
  function spawnRock(x, y, vx, vy) {
    rocks.push({
      x,
      y,
      vx,
      vy,
      size: 6,
      alive: true
    });
  }

  // Emit a radial burst of particles when a rock shatters.
  function spawnRockExplosion(x, y) {
    const count = 8;
    // Launch each particle in an even spread to mimic a burst.
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const speed = 1.5 + Math.random();
      particles.push({
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 18
      });
    }
  }

  // Advance the octorok AI, including movement, attacks, and reactions to damage.
  function updateOctorok(octorok) {
    octorok.prevVy = octorok.vy;

    // State machine: jump+shoot -> wait -> ground shoot -> wait -> repeat
    // Disabled while in hitstun
    // Only process the AI state machine when not currently in hitstun.
    if (octorok.hitTimer === 0) {
      // React only to the two waiting states because the others are instantaneous.
      if (octorok.state === 'waitAfterShot' || octorok.state === 'waitAfterJump') {
        // Count down the wait timer until it reaches zero.
        if (octorok.stateTimer > 0) {
          octorok.stateTimer--;
        }
        // Transition once the wait timer completes.
        if (octorok.stateTimer <= 0) {
          // Start the aerial attack cycle after finishing the post-shot delay.
          if (octorok.state === 'waitAfterShot') {
            // Begin jump phase
            // Initiate the jump only when the enemy is standing on ground.
            if (octorok.onGround) {
              octorok.vy = octorok.jumpSpeed;
              octorok.onGround = false;
            }
            octorok.shotThisJump = false;
            octorok.state = 'jump';
          // Fire a grounded shot when emerging from the waiting state after a jump.
          } else if (octorok.state === 'waitAfterJump') {
            // Grounded shot
            const mouthSize = 4;
            const mouthX = octorok.x - 2;
            const mouthY = octorok.y + octorok.height / 2 - mouthSize / 2;
            spawnRock(mouthX - 2, mouthY, -2.5, 0);
            // Now wait again before the next jump+shoot
            octorok.state = 'waitAfterShot';
            octorok.stateTimer = 60;
          }
        }
      }
    }

    // Gravity
    octorok.vy += octorok.gravity;
    // Clamp falling speed so gravity does not accelerate forever.
    if (octorok.vy > octorok.maxFall) octorok.vy = octorok.maxFall;

    // Horizontal movement from knockback
    let newX = octorok.x + octorok.vx;
    // Move horizontally only if the destination is not blocked by terrain.
    if (!rectVsWorld(newX, octorok.y, octorok.width, octorok.height)) {
      octorok.x = newX;
    } else {
      octorok.vx = 0;
    }

    // Vertical collision
    let newY = octorok.y + octorok.vy;
    // Apply vertical motion as long as the body is not intersecting the map.
    if (!rectVsWorld(octorok.x, newY, octorok.width, octorok.height)) {
      octorok.y = newY;
      octorok.onGround = false;
    } else {
      // Resolve downward collisions differently from upward collisions.
      if (octorok.vy > 0) {
        // Step the sprite down until touching ground so it lands cleanly.
        while (!rectVsWorld(octorok.x, octorok.y + 1, octorok.width, octorok.height)) {
          octorok.y += 1;
        }
        octorok.onGround = true;
        // When a jump finishes, transition into the waiting state.
        if (octorok.state === 'jump') {
          octorok.state = 'waitAfterJump';
          octorok.stateTimer = 60;
        }
      } else if (octorok.vy < 0) {
        // Step upward until the head clears the ceiling to avoid clipping.
        while (!rectVsWorld(octorok.x, octorok.y - 1, octorok.width, octorok.height)) {
          octorok.y -= 1;
        }
      }
      octorok.vy = 0;
    }

    // Friction on ground for knockback
    // Apply friction only when grounded so knockback tapers off.
    if (octorok.onGround) {
      octorok.vx *= 0.85;
      // Zero-out extremely tiny velocities to avoid jittering.
      if (Math.abs(octorok.vx) < 0.05) octorok.vx = 0;
    }

    const wasHit = octorok.hitTimer > 0;
    // Count down hitstun frames until the enemy recovers.
    if (octorok.hitTimer > 0) {
      octorok.hitTimer--;
    }

    // Shoot a rock at the apex of the jump during the jump phase (no shooting while in hitstun)
    if (octorok.hitTimer === 0 &&
        !octorok.onGround && !octorok.shotThisJump &&
        octorok.prevVy <= 0 && octorok.vy > 0 &&
        octorok.state === 'jump') {
      const mouthSize = 4;
      const mouthX = octorok.x - 2;
      const mouthY = octorok.y + octorok.height / 2 - mouthSize / 2;
      spawnRock(mouthX - 2, mouthY, -2.5, 0);
      octorok.shotThisJump = true;
    }

    // When hitstun ends, reset the pattern
    if (wasHit && octorok.hitTimer === 0) {
      octorok.state = 'waitAfterShot';
      octorok.stateTimer = 60;
      octorok.shotThisJump = false;
    }

    // Tick the idle animation timer every frame so it loops forever.
    octorok.idleAnimTimer++;
    // Advance to the next idle frame once the configured duration elapses.
    if (octorok.idleAnimTimer >= OCTOROK_IDLE_FRAME_DURATION) {
      octorok.idleAnimTimer = 0;
      octorok.idleAnimFrame = (octorok.idleAnimFrame + 1) % 2;
    }
  }

  // Resolve Link's sword strikes and collision responses against a specific octorok.
  function handleOctorokPlayerInteractions(octorok) {
    const sword = swordHitbox();
    // Only damage the enemy when Link is actively stabbing and the octorok is vulnerable.
    if (sword && rectsOverlap(sword, octorok) && octorok.hitTimer === 0) {
      octorok.hitTimer = 10;
      const knockDir = player.facing;
      octorok.vx = 3 * knockDir;
      octorok.vy = -2.5;
    }

    // Evaluate body collisions only when Link is not already recovering from damage.
    if (player.hitTimer === 0) {
      const playerBox = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };
      // Trigger knockback and invulnerability when Link bumps into the enemy.
      if (rectsOverlap(playerBox, octorok)) {
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const enemyCenter = octorok.x + octorok.width / 2;
        const dir = playerCenter < enemyCenter ? -1 : 1;

        // Immediately separate horizontally so we don't stay overlapping.
        // Push Link to the left when he was positioned on that side of the enemy.
        if (dir < 0) {
          player.x = octorok.x - player.width - 1;
        } else {
          player.x = octorok.x + octorok.width + 1;
        }

        player.vx = dir * 3.2;
        player.vy = -4;
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }
  }

  // Advance the Armos Knight's idle, shield, and attack timers.
  function updateArmosKnight(knight) {
    const playerCenter = player.x + player.width / 2;
    const knightCenter = knight.x + knight.width / 2;
    // Face toward Link so the shield and sword always orient correctly.
    knight.facing = playerCenter < knightCenter ? -1 : 1;

    // Count down the brief hit flash timer if the knight was recently struck.
    if (knight.hitTimer > 0) {
      knight.hitTimer--;
    }

    // Apply horizontal knockback velocity while the recoil timer is still active.
    if (knight.knockbackTimer > 0) {
      knight.x += knight.vx;
      knight.vx *= 0.85;
      knight.knockbackTimer--;
    } else if (Math.abs(knight.vx) > 0.01) {
      // Stop any tiny drift that remains once the recoil period ends.
      knight.vx = 0;
    }

    // Determine whether Link is close enough to trigger the knight's footwork.
    const distanceToPlayer = Math.abs(playerCenter - knightCenter);
    const engaging = distanceToPlayer <= knight.engageRange;
    // Compute the minimum safe spacing so the knight's body never willingly overlaps Link's.
    const minBodyDistance = (player.width + knight.width) / 2 + 2;
    let walkStep = 0;
    // Only walk when not recoiling so the knockback has visible impact.
    if (engaging && knight.knockbackTimer === 0) {
      knight.walkTimer++;
      // Shuffle forward/backward using a sine wave so the knight drifts in and out of range.
      const shufflePhase = (knight.walkTimer / knight.shufflePeriod) * Math.PI * 2;
      const shuffleOffset = Math.sin(shufflePhase) * knight.shuffleAmplitude;
      // Clamp the desired distance so the shuffle pattern never pulls the knight into body contact.
      const targetDistance = Math.max(minBodyDistance, knight.desiredRange + shuffleOffset);
      const desiredCenter = playerCenter - knight.facing * targetDistance;
      const desiredX = desiredCenter - knight.width / 2;
      // Smoothly chase the desired position so Link can rush in before the knight reacts.
      knight.walkTargetX += (desiredX - knight.walkTargetX) * knight.walkResponsiveness;
      const delta = knight.walkTargetX - knight.x;
      const maxStep = knight.walkSpeed;
      walkStep = Math.max(-maxStep, Math.min(maxStep, delta));
      knight.x += walkStep;
    } else if (!engaging) {
      // Reset the target point when disengaged so he holds his ground.
      knight.walkTimer = 0;
      knight.walkTargetX = knight.x;
    }
    knight.lastWalkStep = walkStep;
    knight.walking = Math.abs(walkStep) > 0.02;
    // Update the foot cycle whenever the knight is actively marching.
    if (knight.walking) {
      knight.walkAnimTimer++;
      if (knight.walkAnimTimer >= WALK_ANIM_FRAME_DURATION) {
        knight.walkAnimTimer = 0;
        knight.walkAnimFrame = (knight.walkAnimFrame + 1) % 2;
      }
    } else {
      knight.walkAnimTimer = 0;
      knight.walkAnimFrame = 0;
    }

    // When the knight is swinging, keep ticking through the attack animation frames.
    if (knight.attacking) {
      knight.attackTimer++;
      // Return to idle once the windup, stab, and recovery have all played out.
      if (knight.attackTimer >= knight.attackDuration) {
        knight.attacking = false;
        knight.attackTimer = 0;
        knight.attackCooldown = 180 + Math.floor(Math.random() * 60);
        knight.blockedThisSwing = false;
      }
    } else {
      // Count down the idle cooldown until it is time to launch another strike.
      if (knight.attackCooldown > 0) {
        knight.attackCooldown--;
      }
      // Start a new attack sequence once the cooldown elapses.
      if (knight.attackCooldown <= 0) {
        knight.attacking = true;
        knight.attackTimer = 0;
        knight.attackHeight = Math.random() < 0.5 ? 'high' : 'low';
        knight.blockedThisSwing = false;
      }
    }

    // Only consider changing shield positions when Link is not applying pressure.
    if (!player.attacking) {
      knight.shieldChangeTimer++;
      // Every two seconds roll a coin flip to potentially swap the shield height.
      if (knight.shieldChangeTimer >= 120) {
        knight.shieldChangeTimer = 0;
        // Flip the stance roughly half the time to keep Link guessing.
        if (Math.random() < 0.5) {
          knight.shieldHigh = !knight.shieldHigh;
        }
      }
    } else {
      // Reset the timer while Link is mid-attack so the cadence restarts afterward.
      knight.shieldChangeTimer = 0;
    }
  }

  // Build the knight's shield collision box for the current pose so Link's sword can bounce off of it.
  function knightShieldHitbox(knight) {
    const shieldWidth = TILE_SIZE * 0.6;
    const shieldHeight = TILE_SIZE - 2;
    const shieldX = knight.facing > 0
      ? knight.x + knight.width - shieldWidth + 1
      : knight.x - 1;
    const shieldY = knight.shieldHigh
      ? knight.y + 2
      : knight.y + knight.height - shieldHeight;
    return {
      x: shieldX,
      y: shieldY,
      width: shieldWidth,
      height: shieldHeight
    };
  }

  // Determine which segment of the attack animation is currently playing for the knight.
  function knightAttackPhase(knight) {
    if (!knight.attacking) return 'idle';
    const t = knight.attackTimer;
    if (t < knight.attackWindup) return 'windup';
    if (t < knight.attackWindup + knight.attackStab) return 'stab';
    return 'recover';
  }

  // Compute the sword's rectangle for rendering and collision so they always stay in sync.
  function knightSwordPose(knight) {
    const phase = knightAttackPhase(knight);
    if (phase === 'idle') return null;

    const swordWidth = 4;
    let swordLength = TILE_SIZE;
    let forwardAdjust = 0;

    // Gradually pull the sword back during the windup to create a telegraphed motion.
    if (phase === 'windup') {
      const windupProgress = knight.attackWindup === 0
        ? 1
        : knight.attackTimer / knight.attackWindup;
      swordLength = TILE_SIZE * 0.8;
      forwardAdjust = -swordLength * (1 - windupProgress);
    // Ease the sword back toward the body while recovering from a stab.
    } else if (phase === 'recover') {
      const recoverElapsed = knight.attackTimer - (knight.attackWindup + knight.attackStab);
      const recoverDuration = Math.max(1, knight.attackRecover);
      const recoverProgress = Math.min(1, recoverElapsed / recoverDuration);
      swordLength = TILE_SIZE * 0.8;
      forwardAdjust = -swordLength * recoverProgress * 0.8;
    }

    const swordX = knight.facing > 0
      ? knight.x + knight.width + forwardAdjust
      : knight.x - swordLength - forwardAdjust;
    const verticalOffset = knight.attackHeight === 'high'
      ? 4
      : knight.height - TILE_SIZE / 2;
    const swordY = knight.y + verticalOffset - (phase === 'windup' ? 2 : 0);

    return {
      phase,
      rect: {
        x: swordX,
        y: swordY,
        width: swordLength,
        height: swordWidth
      }
    };
  }

  // Create the knight's sword hitbox whenever the attack animation reaches the active stab frames.
  function knightSwordHitbox(knight) {
    const pose = knightSwordPose(knight);
    // Abort when the knight is not currently swinging the sword.
    if (!pose || pose.phase !== 'stab') return null;
    return pose.rect;
  }

  // Evaluate collisions between Link and the Armos Knight, including sword clashes and body bumps.
  function handleArmosKnightVsPlayer(knight) {
    const sword = swordHitbox();
    const knightShield = knightShieldHitbox(knight);
    const playerBox = {
      x: player.x,
      y: player.y,
      width: player.width,
      height: player.height
    };
    // Only attempt to damage the knight when Link is mid-stab and the shield does not intercept the blade.
    if (sword && knight.hitTimer === 0) {
      const swordBlocked = rectsOverlap(sword, knightShield);
      // Only register damage if the blade sneaks around the shield and touches the body.
      if (!swordBlocked && rectsOverlap(sword, knight)) {
        knight.hitTimer = 14;
        const knockDir = player.facing;
        knight.vx = knockDir * 2.5;
        knight.knockbackTimer = 12;
      } else if (swordBlocked && !player.blockedThisSwing) {
        // Recoil Link slightly when the shield successfully blocks the strike.
        const recoilDir = player.facing;
        player.x -= recoilDir * 1.5;
        player.vx = -recoilDir * 2.0;
        player.vy = Math.min(player.vy, -1);
        player.blockedThisSwing = true;
        // Also push the knight backward so the clash feels mutual.
        knight.vx = recoilDir * 1.6;
        knight.knockbackTimer = Math.max(knight.knockbackTimer, 8);
      }
    }

    // Treat the knight like a solid enemy so touching it hurts Link.
    if (player.hitTimer === 0) {
      // Apply damage when Link's hurtbox overlaps the knight's body.
      if (rectsOverlap(playerBox, knight)) {
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const enemyCenter = knight.x + knight.width / 2;
        const dir = playerCenter < enemyCenter ? -1 : 1;

        // Push Link to whichever side he should bounce away toward.
        if (dir < 0) {
          player.x = knight.x - player.width - 1;
        } else {
          player.x = knight.x + knight.width + 1;
        }

        player.vx = dir * 3.2;
        player.vy = -4;
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }

    const knightSword = knightSwordHitbox(knight);
    // Let the knight's sword harm Link when it slips past the hero's shield.
    if (knightSword && player.hitTimer === 0) {
      const shieldBox = shieldHitbox();
      const swordHitsPlayer = rectsOverlap(knightSword, playerBox);
      const shieldBlocksSword = rectsOverlap(knightSword, shieldBox);
      // Hurt Link only when the sword overlaps his body without being blocked by the shield.
      if (swordHitsPlayer && !shieldBlocksSword) {
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const enemyCenter = knight.x + knight.width / 2;
        const dir = playerCenter < enemyCenter ? -1 : 1;
        player.vx = dir * 3.2;
        player.vy = -4;
        player.x += dir * 1.5;
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      } else if (shieldBlocksSword && !knight.blockedThisSwing) {
        // Bounce both fighters apart when Link successfully blocks the stab.
        const blockDir = knight.facing;
        player.vx = blockDir * 1.6;
        player.x += blockDir * 0.5;
        player.vy = Math.min(player.vy, -1);
        knight.vx = -blockDir * 2.2;
        knight.knockbackTimer = Math.max(knight.knockbackTimer, 10);
        knight.blockedThisSwing = true;
      }
    }
  }

  // Compute the player's shield hitbox, accounting for crouching and facing.
  function shieldHitbox() {
    const shieldWidth = TILE_SIZE * 0.6;
    const shieldHeight = TILE_SIZE;
    let shieldY;
    // Anchor the shield lower while crouching so it covers Link's knees.
    if (player.crouching) {
      shieldY = player.y + player.height - shieldHeight;
    } else {
      shieldY = player.y + TILE_SIZE * 0.2;
    }
    let shieldX;
    // Offset the shield based on facing so it always sits in front of Link.
    if (player.facing > 0) {
      shieldX = player.x + player.width - shieldWidth + 1;
    } else {
      shieldX = player.x - 1;
    }
    return {
      x: shieldX,
      y: shieldY,
      width: shieldWidth,
      height: shieldHeight
    };
  }

  // Move active projectiles and particles while handling their collisions.
  function updateRocksAndParticles() {
    // Rocks
    // Step through each projectile to update its physics and collisions.
    for (const rock of rocks) {
      // Skip rocks that already exploded so they don't keep updating.
      if (!rock.alive) continue;
      rock.x += rock.vx;
      rock.y += rock.vy;

      const rockBox = {
        x: rock.x,
        y: rock.y,
        width: rock.size,
        height: rock.size
      };

      const shieldBox = shieldHitbox();
      const playerBox = {
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height
      };

      let exploded = false;
      // Shield blocks the rock
      if (rectsOverlap(rockBox, shieldBox)) {
        exploded = true;
      } else if (rectsOverlap(rockBox, playerBox) && player.hitTimer === 0) {
        // Hit the player
        player.hitTimer = 24;
        const playerCenter = player.x + player.width / 2;
        const projCenter = rock.x + rock.size / 2;
        const dir = playerCenter < projCenter ? -1 : 1;
        player.vx = dir * 3.0;
        player.vy = -4;
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
        exploded = true;
      }

      // Offscreen
      // Blow up the projectile if it wanders far outside the current view to keep arrays small.
      const offscreenPadding = TILE_SIZE * 4;
      const viewLeft = cameraX - offscreenPadding;
      const viewRight = cameraX + canvas.width + offscreenPadding;
      const viewTop = -offscreenPadding;
      const viewBottom = canvas.height + offscreenPadding;
      if (rock.x + rock.size < viewLeft || rock.x > viewRight ||
          rock.y + rock.size < viewTop || rock.y > viewBottom) {
        exploded = true;
      }

      // Convert the rock into particles after any collision or despawn event.
      if (exploded) {
        rock.alive = false;
        spawnRockExplosion(rock.x + rock.size / 2, rock.y + rock.size / 2);
      }
    }

    // Compact rocks array
    // Walk the array backwards so splices do not skip entries.
    for (let i = rocks.length - 1; i >= 0; i--) {
      // Remove any rock marked as dead to prevent future updates.
      if (!rocks[i].alive) rocks.splice(i, 1);
    }

    // Particles
    // Update each particle's position and fade over time.
    for (const p of particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.05;
      p.life--;
    }
    // Clean up expired particles from the tail end first.
    for (let i = particles.length - 1; i >= 0; i--) {
      if (particles[i].life <= 0) particles.splice(i, 1);
    }
  }

  // Handle player input, physics, combat, and reactions to damage.
  function updatePlayer() {
    // Pull together keyboard, touch, and controller state so gameplay reads from one source.
    const inputKeys = combinedInputKeys();

    // Detect a fresh press of the attack button so holding it down does not chain multiple swings.
    const attackJustPressed = inputKeys.j && !lastAttackPressed;
    // Detect a fresh press of the jump button so holding it down does not trigger repeated jumps.
    const jumpJustPressed = inputKeys.k && !lastJumpPressed;

    // Horizontal input (used for facing even while attacking)
    let inputDir = 0;
    // Tilt left when the virtual left input is held down.
    if (inputKeys.a) inputDir -= 1;
    // Tilt right when the virtual right input is held down.
    if (inputKeys.d) inputDir += 1;

    const lockMovement = (player.attacking && player.onGround) || player.hitTimer > 0;
    const moveX = lockMovement ? 0 : inputDir;

    // Crouch (S) can be used on ground or in air,
    // but you can't change crouch state during an attack
    const wasCrouching = player.crouching;
    // Allow crouch toggles only when not attacking or flinching.
    if (!player.attacking && player.hitTimer === 0) {
      player.crouching = inputKeys.s;
    }

    // Adjust collision box when crouching / standing
    if (player.crouching !== wasCrouching) {
      // Shrink the player's collider whenever crouching begins.
      if (player.crouching) {
        const delta = player.standHeight - player.crouchHeight;
        player.y += delta;
        player.height = player.crouchHeight;
      // Try to return to full height if the crouch is released.
      } else {
        const delta = player.standHeight - player.crouchHeight;
        const newY = player.y - delta;
        // Only stand up if there is room
        if (!rectVsWorld(player.x, newY, player.width, player.standHeight)) {
          player.y = newY;
          player.height = player.standHeight;
        } else {
          // Stay crouched if overhead terrain blocks the stand-up attempt.
          player.crouching = true;
        }
      }
    }

    // Facing direction (ignore zero movement)
    if (inputDir !== 0) {
      player.facing = inputDir > 0 ? 1 : -1;
    }

    // Apply horizontal velocity (no air control damping)
    // During hit-stun, preserve knockback velocity instead of overriding it
    // Only override movement while Link is not recoiling from damage.
    if (player.hitTimer === 0) {
      player.vx = moveX * player.speed;
    }

    // Jump (virtual K)
    // Trigger a jump only when the virtual jump button transitions from up to down while grounded and free to move.
    if (jumpJustPressed && player.onGround && !player.attacking && player.hitTimer === 0) {
      player.vy = player.jumpSpeed;
      player.onGround = false;
    }

    // Gravity
    player.vy += player.gravity;
    // Prevent falling speed from exceeding the cap.
    if (player.vy > player.maxFall) player.vy = player.maxFall;

    // Horizontal collision
    let newX = player.x + player.vx;
    // Slide freely when the path ahead is clear.
    if (!rectVsWorld(newX, player.y, player.width, player.height)) {
      player.x = newX;
    } else {
      // slide
      // Walk pixel-by-pixel into the wall to land flush without overlapping.
      while (!rectVsWorld(player.x + Math.sign(player.vx), player.y, player.width, player.height)) {
        player.x += Math.sign(player.vx);
      }
      player.vx = 0;
    }

    // Vertical collision
    let newY = player.y + player.vy;
    // Allow freefall whenever the new position is unobstructed.
    if (!rectVsWorld(player.x, newY, player.width, player.height)) {
      player.y = newY;
      player.onGround = false;
    } else {
      // Handle downward impacts differently from upward hits.
      if (player.vy > 0) {
        // Landing on ground
        // Step downward until feet touch the floor to avoid sinking.
        while (!rectVsWorld(player.x, player.y + 1, player.width, player.height)) {
          player.y += 1;
        }
        player.onGround = true;
      } else if (player.vy < 0) {
        // Hitting ceiling
        // Step upward until the head clears to keep the body outside tiles.
        while (!rectVsWorld(player.x, player.y - 1, player.width, player.height)) {
          player.y -= 1;
        }
      }
      player.vy = 0;
    }

    // Attack (virtual J) - standing or crouching allowed
    // Start a new stab only when the attack button transitions from up to down and Link is free to act.
    if (attackJustPressed && !player.attacking && player.hitTimer === 0) {
      player.attacking = true;
      player.attackTimer = 0;
      player.blockedThisSwing = false;
    }

    // Count through the attack animation frames.
    if (player.attacking) {
      player.attackTimer++;
      // End the attack when the animation timer completes.
      if (player.attackTimer >= player.attackDuration) {
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }

    // Taper off hurt invulnerability each frame until it hits zero.
    if (player.hitTimer > 0) {
      player.hitTimer--;
    }

    // Determine whether Link is currently walking so the animation can advance.
    const currentlyWalking =
      player.onGround &&
      Math.abs(player.vx) > 0.1 &&
      !player.crouching &&
      player.hitTimer === 0 &&
      !player.attacking;
    player.walking = currentlyWalking;
    // Update the walking animation timer/frame whenever movement is happening.
    if (currentlyWalking) {
      player.walkAnimTimer++;
      // Swap frames every few ticks to create a two-step cycle.
      if (player.walkAnimTimer >= WALK_ANIM_FRAME_DURATION) {
        player.walkAnimTimer = 0;
        player.walkAnimFrame = (player.walkAnimFrame + 1) % 2;
      }
    } else {
      // Reset the walk animation when standing still so it starts from frame 0.
      player.walkAnimTimer = 0;
      player.walkAnimFrame = 0;
    }

    // Remember whether the attack and jump inputs are held for the next frame so we can continue to detect edge presses.
    lastAttackPressed = inputKeys.j;
    lastJumpPressed = inputKeys.k;

  }

  // Handle free movement inside the raised-view town where up/down map to depth while jumps lift vertically.
  function updateRaisedPlayer() {
    const inputKeys = combinedInputKeys();

    // Detect a fresh press of the attack button so holding it down does not chain multiple swings.
    const attackJustPressed = inputKeys.j && !lastAttackPressed;
    // Detect a fresh jump press so the leap only fires once per key edge.
    const jumpJustPressed = inputKeys.k && !lastJumpPressed;

    // Compute directional intent using both axes so Link can walk diagonally across the plaza.
    let moveX = 0;
    let moveZ = 0;
    // Honor leftward input by subtracting from the horizontal axis.
    if (inputKeys.a) moveX -= 1;
    // Honor rightward input by adding to the horizontal axis.
    if (inputKeys.d) moveX += 1;
    // Honor upward input by subtracting from the depth axis to walk away from the camera while grounded.
    if (player.onGround && inputKeys.w) moveZ -= 1;
    // Honor downward input by adding to the depth axis to walk toward the camera while grounded.
    if (player.onGround && inputKeys.s) moveZ += 1;

    // Normalize diagonal walks so pace remains consistent in every direction.
    const magnitude = Math.hypot(moveX, moveZ);
    const moveScale = magnitude > 0 ? player.speed / magnitude : 0;
    const scaledMoveX = moveX * moveScale;
    const scaledMoveZ = moveZ * moveScale;

    // Turn to face the most recent horizontal input while leaving vertical strafe unchanged.
    if (moveX !== 0) {
      player.facing = moveX > 0 ? 1 : -1;
    }

    // Keep combat state simple by disabling crouch in the raised view.
    player.crouching = false;
    player.height = player.standHeight;

    // Trigger a leap while grounded so the jump arc does not chain repeatedly.
    if (jumpJustPressed && player.onGround && !player.attacking && player.hitTimer === 0) {
      player.onGround = false;
      player.vy = player.jumpSpeed;
    }

    // Apply gravity and vertical movement when airborne while keeping depth locked.
    if (!player.onGround) {
      player.vy = Math.min(player.vy + player.gravity, player.maxFall);
      player.y += player.vy;
      // Snap back to the ground plane when the jump arc finishes.
      if (player.y >= player.z) {
        player.y = player.z;
        player.vy = 0;
        player.onGround = true;
      }
    } else {
      player.vy = 0;
      player.y = player.z;
    }

    const proposedX = player.x + scaledMoveX;
    const proposedZ = player.z + scaledMoveZ;

    // Exit back to the overworld once Link walks past either entrance edge of town.
    if (proposedX < -TILE_SIZE / 2) {
      returnToOverworldFromTown('left');
      return true;
    }
    if (proposedX > TOWN_TOTAL_WIDTH - player.width + TILE_SIZE / 2) {
      returnToOverworldFromTown('right');
      return true;
    }

    // Apply horizontal movement only when the path stays clear of buildings.
    if (!townRectVsWorld(proposedX, player.z, player.width, player.height)) {
      player.x = proposedX;
    }
    // Apply depth movement only when the path stays clear of scenery and the player is grounded.
    if (!townRectVsWorld(player.x, proposedZ, player.width, player.height)) {
      player.z = proposedZ;
      if (player.onGround) {
        player.y = player.z;
      }
    }

    // Attack (virtual J) - available for timing practice even without enemies.
    if (attackJustPressed && !player.attacking && player.hitTimer === 0) {
      player.attacking = true;
      player.attackTimer = 0;
      player.blockedThisSwing = false;
    }

    // Count through the attack animation frames when active.
    if (player.attacking) {
      player.attackTimer++;
      // End the attack when the animation timer completes.
      if (player.attackTimer >= player.attackDuration) {
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }

    // Taper off hurt invulnerability each frame until it hits zero.
    if (player.hitTimer > 0) {
      player.hitTimer--;
    }

    // Determine whether Link is currently walking so the animation can advance.
    const currentlyWalking =
      (Math.abs(scaledMoveX) > 0.05 || Math.abs(scaledMoveZ) > 0.05) &&
      player.hitTimer === 0 &&
      !player.attacking;
    player.walking = currentlyWalking;
    // Update the walking animation timer/frame whenever movement is happening.
    if (currentlyWalking) {
      player.walkAnimTimer++;
      // Swap frames every few ticks to create a two-step cycle.
      if (player.walkAnimTimer >= WALK_ANIM_FRAME_DURATION) {
        player.walkAnimTimer = 0;
        player.walkAnimFrame = (player.walkAnimFrame + 1) % 2;
      }
    } else {
      // Reset the walk animation when standing still so it starts from frame 0.
      player.walkAnimTimer = 0;
      player.walkAnimFrame = 0;
    }

    // Remember whether the attack and jump inputs are held for the next frame so we can continue to detect edge presses.
    lastAttackPressed = inputKeys.j;
    lastJumpPressed = inputKeys.k;

    return false;
  }

  // Render the tile-based ground layout relative to the camera.
  function drawWorld() {
    const startTileX = Math.floor(cameraX / TILE_SIZE);
    const endTileX = Math.floor((cameraX + canvas.width) / TILE_SIZE) + 1;
    // Walk each row in the playfield so we can render any visible tiles.
    for (let y = 0; y < WORLD_ROWS; y++) {
      // Inspect every column that overlaps the current viewport.
      for (let tileX = startTileX; tileX <= endTileX; tileX++) {
        if (tileAtTileCoordinates(tileX, y) === 1) {
          const drawX = tileX * TILE_SIZE - cameraX;
          ctx.fillStyle = '#303060';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = '#505090';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, 4);
        }
      }
    }
  }

  // Render the raised-view town tiles relative to the current camera offset.
  function drawTownWorld() {
    const startTileX = Math.floor(cameraX / TILE_SIZE);
    const endTileX = Math.floor((cameraX + canvas.width) / TILE_SIZE) + 1;
    // Walk each row in the plaza so we can render any visible scenery tiles.
    for (let y = 0; y < WORLD_ROWS; y++) {
      // Inspect every column that overlaps the current viewport.
      for (let tileX = startTileX; tileX <= endTileX; tileX++) {
        // Render only the solid scenery tiles while skipping open floor.
        if (townTileAtTileCoordinates(tileX, y) === 1) {
          const drawX = tileX * TILE_SIZE - cameraX;
          ctx.fillStyle = '#2e2e52';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = '#5a628a';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, 4);
        }
      }
    }
  }

  // Draw the octorok enemy with its simple animation cues.
  function drawOctorok(octorok) {
    const x = Math.floor(octorok.x - cameraX);
    const y = Math.floor(octorok.y);
    const w = octorok.width;
    const h = octorok.height;
    // Compute the small bobbing offset used by the idle animation.
    const bobOffset = octorok.idleAnimFrame === 0 ? 0 : 1;
    // Compute how far the tentacles lift to create a two-frame cycle.
    const tentacleLift = octorok.idleAnimFrame === 0 ? 0 : 2;

    // Flash when hit
    if (octorok.hitTimer > 0 && (octorok.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#ff7040';
    }
    ctx.fillRect(x, y + bobOffset, w, h - bobOffset);

    // Simple eyes
    ctx.fillStyle = '#000000';
    // Offset the eyes upward during the lifted frame so the whole sprite moves.
    const eyeY = y + 4 + bobOffset - (octorok.idleAnimFrame === 0 ? 0 : 1);
    ctx.fillRect(x + 3, eyeY, 3, 3);
    ctx.fillRect(x + w - 6, eyeY, 3, 3);

    // Little mouth on its left side
    ctx.fillStyle = '#602020';
    const mouthWidth = 4;
    const mouthHeight = 3;
    const mouthX = x - 1;
    const mouthY = y + h / 2 - mouthHeight / 2 + bobOffset;
    ctx.fillRect(Math.floor(mouthX), Math.floor(mouthY), mouthWidth, mouthHeight);

    // Animated tentacles that alternate height every other frame.
    ctx.fillStyle = '#ff905c';
    const tentacleY = y + h - 3 - tentacleLift + bobOffset;
    ctx.fillRect(x, tentacleY, w, 3);
  }

  // Render the Armos Knight along with its shield and sword indicators.
  function drawArmosKnight(knight) {
    const renderX = Math.floor(knight.x - cameraX);
    const renderY = Math.floor(knight.y);
    const w = knight.width;
    const h = knight.height;

    // Flash white while in hitstun to provide quick feedback.
    if (knight.hitTimer > 0 && (knight.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#a04040';
    }
    ctx.fillRect(renderX, renderY, w, h);

    // Draw a darker trim to hint at armor plating.
    ctx.fillStyle = '#702828';
    ctx.fillRect(renderX, renderY, w, 4);
    ctx.fillRect(renderX, renderY + h - 4, w, 4);

    // Simple footfalls that alternate height while walking.
    const footHeight = 4;
    const footBaseY = renderY + h - footHeight;
    const legWidth = Math.floor(w / 2);
    const leftLift = knight.walking && knight.walkAnimFrame === 0 ? 2 : 0;
    const rightLift = knight.walking && knight.walkAnimFrame === 1 ? 2 : 0;
    ctx.fillStyle = '#651a1a';
    ctx.fillRect(renderX, footBaseY - leftLift, legWidth, footHeight);
    ctx.fillRect(renderX + legWidth, footBaseY - rightLift, w - legWidth, footHeight);

    // Depict the helmet with a lighter band.
    ctx.fillStyle = '#d89060';
    ctx.fillRect(renderX, renderY, w, Math.floor(TILE_SIZE / 2));

    const shield = knightShieldHitbox(knight);
    ctx.fillStyle = '#c4c8d8';
    ctx.fillRect(Math.floor(shield.x - cameraX), Math.floor(shield.y), shield.width, shield.height);
    ctx.fillStyle = '#8a8fa8';
    ctx.fillRect(Math.floor(shield.x - cameraX) + 1, Math.floor(shield.y) + 2, shield.width - 2, shield.height - 4);

    const swordPose = knightSwordPose(knight);
    // Only draw the sword when the animation is active.
    if (swordPose) {
      const { rect, phase } = swordPose;
      const swordScreenX = Math.floor(rect.x - cameraX);
      const swordScreenY = Math.floor(rect.y);
      ctx.fillStyle = phase === 'windup' ? '#ffd480' : '#f0f0f0';
      ctx.fillRect(swordScreenX, swordScreenY, rect.width, rect.height);
      // Add a subtle glow during the windup so players can spot the upcoming strike.
      if (phase === 'windup') {
        ctx.fillStyle = 'rgba(255, 215, 130, 0.35)';
        ctx.fillRect(swordScreenX - 1, swordScreenY - 1, rect.width + 2, rect.height + 2);
      }
      ctx.fillStyle = '#c8a060';
      const hiltX = knight.facing > 0
        ? Math.floor(knight.x + knight.width - cameraX)
        : Math.floor(knight.x - 6 - cameraX);
      ctx.fillRect(hiltX, swordScreenY - 2, 6, 2);
    }
  }

  // Render the player character, including sword and shield.
  function drawPlayer() {
    const renderX = Math.floor(player.x - cameraX);
    const renderY = Math.floor(player.y);

    // Base body color (flash when hit)
    if (player.hitTimer > 0 && (player.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#2f9e44';
    }

    // Body (simple rectangle)
    ctx.fillRect(renderX, renderY, player.width, player.height);

    // Head (top section)
    const headHeight = Math.min(TILE_SIZE, player.height);
    if (player.hitTimer > 0 && (player.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#ffe6a0';
    }
    ctx.fillRect(renderX, renderY, player.width, headHeight);

    // Simple helmet / hair band
    ctx.fillStyle = '#40a040';
    ctx.fillRect(renderX, renderY, player.width, 4);

    // Draw the feet with a tiny two-frame walking cycle.
    const footHeight = 4;
    const footBaseY = Math.floor(player.y + player.height - footHeight);
    const legWidth = Math.floor(player.width / 2);
    // Lift the left leg during the first walk frame.
    const leftLift = player.walking && player.walkAnimFrame === 0 ? 2 : 0;
    // Lift the right leg during the second walk frame.
    const rightLift = player.walking && player.walkAnimFrame === 1 ? 2 : 0;
    ctx.fillStyle = '#1f6e32';
    // Left foot rectangle that raises when the leg lifts.
    ctx.fillRect(renderX, footBaseY - leftLift, legWidth, footHeight);
    // Right foot rectangle that raises during its corresponding frame.
    ctx.fillRect(Math.floor(player.x + legWidth - cameraX), footBaseY - rightLift, player.width - legWidth, footHeight);

    // Shield (position depends on crouch / stand)
    const sBox = shieldHitbox();
    ctx.fillStyle = '#b0c0ff';
    ctx.fillRect(Math.floor(sBox.x - cameraX), Math.floor(sBox.y), sBox.width, sBox.height);
    ctx.fillStyle = '#8090d0';
    ctx.fillRect(Math.floor(sBox.x - cameraX) + 1, Math.floor(sBox.y) + 2, sBox.width - 2, sBox.height - 4);

    // Sword stab
    if (player.attacking) {
      const t = player.attackTimer;
      let phase = 'recover';
      // Treat early frames as the windup phase.
      if (t < player.attackWindup) {
        phase = 'windup';
      // Treat middle frames as the thrusting phase.
      } else if (t < player.attackWindup + player.attackStab) {
        phase = 'stab';
      }

      // Length / offset by phase
      let swordLength = TILE_SIZE;
      let forwardAdjust = 0;
      // Shorten and retract the blade during the windup.
      if (phase === 'windup') {
        swordLength = TILE_SIZE / 2;
        forwardAdjust = -swordLength / 2;
      // Shorten again while recovering to mimic pulling back.
      } else if (phase === 'recover') {
        swordLength = TILE_SIZE / 2;
        forwardAdjust = -swordLength / 4;
      }

      ctx.fillStyle = '#f8f8f8';
      const swordWidth = 4;
      const swordX = player.facing > 0
        ? player.x + player.width + forwardAdjust
        : player.x - swordLength - forwardAdjust;
      // Lower sword when crouching
      // Use the same lifted offset as the hitbox so visuals and logic align.
      const standingSwordYOffset = TILE_SIZE - swordWidth - 2;
      const baseOffset = player.crouching ? player.height - TILE_SIZE / 2 : standingSwordYOffset;
      const swordY = player.y + baseOffset;
      ctx.fillRect(Math.floor(swordX - cameraX), Math.floor(swordY), swordLength, swordWidth);

      // Hilt
      ctx.fillStyle = '#c8a060';
      const hiltX = player.facing > 0
        ? swordX - 3
        : swordX + swordLength - 1;
      ctx.fillRect(Math.floor(hiltX - cameraX), Math.floor(swordY - 2), 6, 2);
    }
  }

  // Run one frame of the side-scrolling engine, including physics, AI, and rendering.
  function runSideScrollFrame() {
    updatePlayer();
    // Swap to the overworld as soon as Link leaves the starting room to the left.
    if (player.x < -TILE_SIZE / 2) {
      enterOverworldFromSideView();
      return;
    }
    updateCamera();

    const visibleAreas = getVisibleAreaIndices();
    const activeOctoroks = [];
    const activeKnights = [];
    // Gather the enemies that belong to every area visible in or near the camera.
    for (const areaIndex of visibleAreas) {
      const entities = getAreaEntities(areaIndex);
      // Track the area's octorok if it exists so we can update and render it.
      if (entities.octorok) {
        activeOctoroks.push(entities.octorok);
      }
      // Every area includes an Armos Knight, so store the reference for later use.
      if (entities.armosKnight) {
        activeKnights.push(entities.armosKnight);
      }
    }

    // Update each visible octorok before checking for collisions.
    for (const enemy of activeOctoroks) {
      updateOctorok(enemy);
      handleOctorokPlayerInteractions(enemy);
    }

    // Advance each Armos Knight's AI and resolve its interactions with Link.
    for (const knight of activeKnights) {
      updateArmosKnight(knight);
      handleArmosKnightVsPlayer(knight);
    }

    updateRocksAndParticles();

    // Clear
    ctx.fillStyle = '#202048';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawWorld();
    drawPlayer();

    // Render each active octorok.
    for (const enemy of activeOctoroks) {
      drawOctorok(enemy);
    }

    // Render the knights after the player so their swords overlap correctly.
    for (const knight of activeKnights) {
      drawArmosKnight(knight);
    }

    // Draw rocks
    // Iterate over every active projectile to display it.
    for (const rock of rocks) {
      ctx.fillStyle = '#d0b090';
      ctx.fillRect(Math.floor(rock.x - cameraX), Math.floor(rock.y), rock.size, rock.size);
    }

    // Draw particles
    // Iterate across each particle puff to render the debris cloud.
    for (const p of particles) {
      ctx.fillStyle = 'rgba(255, 220, 160, 0.8)';
      ctx.fillRect(Math.floor(p.x - cameraX), Math.floor(p.y), 2, 2);
    }
  }

  // Run one frame of the raised-view town engine that reuses Link's combat controls but with depth movement.
  function runRaisedTownFrame() {
    const exitedTown = updateRaisedPlayer();
    // Stop rendering the town when the player just walked back to the overworld.
    if (exitedTown) return;

    updateTownCamera();

    ctx.fillStyle = '#1b1b34';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawTownWorld();
    drawPlayer();
  }

  // Main game loop that advances simulation and rendering frames.
  function loop() {
    // Branch between the two engines depending on whether Link is in side-view or overworld mode.
    if (gameMode === GAME_MODE_SIDE_SCROLL) {
      runSideScrollFrame();
    } else if (gameMode === GAME_MODE_OVERWORLD) {
      updateOverworld();
      // Only render the overworld scene when we remain inside that mode after processing movement.
      if (gameMode === GAME_MODE_OVERWORLD) {
        drawOverworld();
      }
    } else {
      runRaisedTownFrame();
    }
    requestAnimationFrame(loop);
  }

  loop();
</script>
</body>
</html>
