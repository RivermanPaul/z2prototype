<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Documentation policy: comment every function, conditional, and loop to describe its role. -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <title>Zelda II HTML5 Prototype</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      user-select: none;
      -webkit-user-select: none;
      min-height: 100vh;
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: none;
    }
    #game-layout {
      width: 100%;
      max-width: 960px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 24px 16px 48px;
      box-sizing: border-box;
    }
    #game-stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    canvas {
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      margin: 0 auto;
      background: #202048;
      max-width: 100%;
      height: auto;
    }
    #info {
      text-align: center;
      margin-top: 8px;
      font-size: 14px;
    }
    #info kbd {
      padding: 1px 4px;
      border-radius: 3px;
      border: 1px solid #555;
      background: #222;
      font-family: monospace;
      font-size: 12px;
    }
    #touch-controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 24px;
      margin: 18px auto 32px;
      max-width: 520px;
      padding: 0 16px;
      user-select: none;
      touch-action: manipulation;
    }
    #touch-controls button {
      width: 64px;
      height: 64px;
      border-radius: 14px;
      border: 2px solid #555;
      background: #1d1d2e;
      color: #eee;
      font-size: 18px;
      font-weight: 600;
      text-transform: uppercase;
      box-shadow: inset 0 2px 0 rgba(255,255,255,0.05);
      transition: transform 0.1s ease, background 0.1s ease;
      user-select: none;
      -webkit-user-select: none;
    }
    #touch-controls button:active,
    #touch-controls button.active {
      background: #353562;
      transform: translateY(2px);
    }
    #touch-controls .dpad {
      display: grid;
      grid-template-columns: repeat(3, 64px);
      grid-template-rows: repeat(3, 64px);
      gap: 8px;
    }
    #touch-controls .dpad button {
      font-size: 20px;
    }
    #touch-controls .dpad button.empty {
      visibility: hidden;
      pointer-events: none;
    }
    #touch-controls .actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #touch-controls .actions button {
      width: 88px;
    }
    @media (max-width: 480px) {
      #touch-controls {
        gap: 16px;
      }
      #touch-controls button {
        width: 56px;
        height: 56px;
      }
      #touch-controls .dpad {
        grid-template-columns: repeat(3, 56px);
        grid-template-rows: repeat(3, 56px);
      }
      #touch-controls .actions button {
        width: 72px;
      }
    }
    .mobile-landscape body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      width: 100vw;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    .mobile-landscape #game-layout {
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 32px;
      max-width: none;
      width: 100%;
      height: 100%;
      padding: 0 24px;
      box-sizing: border-box;
    }
    .mobile-landscape #game-stage {
      flex: 1 1 auto;
    }
    .mobile-landscape canvas {
      width: min(calc((100vh - 48px) * 512 / 288), calc(100vw - 220px));
      max-width: none;
      height: auto;
    }
    .mobile-landscape #touch-controls {
      margin: 0;
      flex-direction: column;
      flex-wrap: nowrap;
      gap: 18px;
      max-width: none;
      padding: 0;
    }
    .mobile-landscape #info {
      position: absolute;
      bottom: env(safe-area-inset-bottom, 16px);
      left: 50%;
      transform: translateX(-50%);
      margin-top: 0;
      font-size: 12px;
      opacity: 0.85;
    }
  </style>
</head>
<body>
<div id="game-layout">
  <div id="game-stage">
    <canvas id="game" width="512" height="288"></canvas>
    <div id="info">
      Controls:
      <kbd>W</kbd>/<kbd>A</kbd>/<kbd>S</kbd>/<kbd>D</kbd> move &amp; crouch,
      <kbd>K</kbd> jump,
      <kbd>J</kbd> stab
    </div>
  </div>
  <div id="touch-controls">
    <div class="dpad">
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button data-key="w" aria-label="Up">▲</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button data-key="a" aria-label="Left">◀</button>
      <button data-key="s" aria-label="Down">▼</button>
      <button data-key="d" aria-label="Right">▶</button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
      <button class="empty" tabindex="-1" aria-hidden="true"></button>
    </div>
    <div class="actions">
      <button data-key="j">Stab</button>
      <button data-key="k">Jump</button>
    </div>
  </div>
</div>

<script src="overworld.js"></script>
<script src="octorok.js"></script>
<script src="armos_knight.js"></script>
<script src="town_spearman.js"></script>

<script>
  // Prevent browser UI gestures (scrolling, pinch-zoom, etc.) from interrupting gameplay.
  window.addEventListener('gesturestart', (event) => {
    event.preventDefault();
  });
  // Block scrolling that could be triggered by touchmove events while using on-screen controls.
  window.addEventListener('touchmove', (event) => {
    event.preventDefault();
  }, { passive: false });

  // Basic Zelda II style platformer prototype
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Track whether we are on a small viewport so we can optimize the layout for mobile screens.
  const mobileMediaQuery = window.matchMedia('(max-width: 768px)');

  // Function that toggles a helper class when the layout should stretch to a full-screen landscape view.
  function syncMobileLayoutClass() {
    // Identify when we are both on a mobile-sized viewport and currently in landscape orientation.
    const inLandscapeMobile = mobileMediaQuery.matches && window.matchMedia('(orientation: landscape)').matches;
    // Add the helper class so CSS can drive the full-screen layout in mobile landscape.
    if (inLandscapeMobile) {
      document.documentElement.classList.add('mobile-landscape');
    // Remove the class whenever we leave the mobile landscape configuration.
    } else {
      document.documentElement.classList.remove('mobile-landscape');
    }
  }

  // Ensure the helper class matches the current viewport before the game starts running.
  syncMobileLayoutClass();
  // Update the layout helper class whenever the viewport changes dimensions.
  window.addEventListener('resize', syncMobileLayoutClass);
  window.addEventListener('orientationchange', syncMobileLayoutClass);

  // Attempt to lock the screen orientation to landscape on mobile browsers that support the API for a more immersive view.
  if (mobileMediaQuery.matches && 'orientation' in screen && typeof screen.orientation.lock === 'function') {
    screen.orientation.lock('landscape').catch(() => {});
  }

  // Game mode flags so we can swap between the side-view and overworld engines.
  const GAME_MODE_SIDE_SCROLL = 'side-scroll';
  const GAME_MODE_OVERWORLD = 'overworld';
  const GAME_MODE_RAISED = 'raised';
  let gameMode = GAME_MODE_SIDE_SCROLL;

  // World / tile setup
  const TILE_SIZE = 16;
  const WORLD_ROWS = Math.floor(canvas.height / TILE_SIZE);
  const SCREEN_COLS = Math.floor(canvas.width / TILE_SIZE);
  const AREA_SCREEN_COUNT = 2;
  const AREA_COLS = SCREEN_COLS * AREA_SCREEN_COUNT;
  const AREA_WIDTH = AREA_COLS * TILE_SIZE;
  const TOWN_AREA_COUNT = 2;
  // Each town area is 50% wider than a single screen-width plaza so the camera can scroll before hitting an exit.
  const TOWN_AREA_COLS = Math.floor((AREA_COLS / 2) * 1.5);
  const TOWN_AREA_WIDTH = TOWN_AREA_COLS * TILE_SIZE;
  const TOWN_TOTAL_WIDTH = TOWN_AREA_COUNT * TOWN_AREA_WIDTH;
  const TOWN_GROUND_Z = (WORLD_ROWS - 4) * TILE_SIZE;
  // Width of the invisible connector rectangles that transfer Link between town sections.
  const TOWN_CONNECTOR_WIDTH = TILE_SIZE * 2;
  // Vertical band of the connector rectangles so they sit around the walkway depth.
  const TOWN_CONNECTOR_TOP_Z = TOWN_GROUND_Z - TILE_SIZE * 2;
  const TOWN_CONNECTOR_BOTTOM_Z = TOWN_GROUND_Z + TILE_SIZE * 0.5;
  // Shop interior width: one screen wide so stores feel cozy and do not scroll.
  const SHOP_COLS = SCREEN_COLS;
  const SHOP_WIDTH = SHOP_COLS * TILE_SIZE;
  // Column indices for the shop doorways in each town plaza area so Link can enter the interiors.
  // Move the left plaza's shop door a few tiles left so it sits centered on the building block.
  const TOWN_SHOP_DOOR_COLS = [12, 10];
  // Visual placement of the exterior shop door sprite so it appears on the building facade.
  // Position the doorway at the base of the shopfront so it aligns with the building's bottom edge.
  const TOWN_SHOP_DOOR_VISUAL_ROW_TOP = 5;
  const TOWN_SHOP_DOOR_VISUAL_ROW_BOTTOM = 7;

  // Cache of generated areas so we only build each layout once.
  const areaCache = new Map();
  // Cache enemy instances per area so we can preserve their state when revisiting rooms.
  const areaEntities = new Map();
  // Cache of town enemies so each plaza section preserves its spearmen between visits.
  const townEnemies = new Map();
  // Track the generated raised-view town layouts so each area only builds once.
  const townAreaCache = new Map();
  // Track generated shop interior layouts so each plaza can host its own simple storefront room.
  const townShopAreaCache = new Map();

  // Produce the tile grid for a given area index.
  function generateAreaTiles(areaIndex) {
    const tiles = [];
    // Build the base ground/air layout row-by-row.
    // Iterate over each world row so we can fill in the ground pattern.
    for (let y = 0; y < WORLD_ROWS; y++) {
      const row = [];
      // Populate the row column-by-column so every cell receives either solid ground or air.
      for (let x = 0; x < AREA_COLS; x++) {
        // Keep the bottom two rows solid to act as ground just like the original room.
        if (y === WORLD_ROWS - 2 || y === WORLD_ROWS - 1) {
          row.push(1);
        } else {
          row.push(0);
        }
      }
      tiles.push(row);
    }

    // Add floating platforms. Each step to the right gains one more platform, steps to the
    // left remove one, and the base area starts with a single platform.
    const platformCount = Math.max(0, areaIndex + 1);
    const platformRow = WORLD_ROWS - 6;
    const platformWidth = 6;
    if (platformRow >= 0 && platformCount > 0) {
      const spacing = AREA_COLS / (platformCount + 1);
      // Step through each platform slot so we can drop solid ledges across the span.
      for (let i = 0; i < platformCount; i++) {
        const center = Math.round(spacing * (i + 1));
        const start = Math.max(1, Math.min(AREA_COLS - platformWidth - 1, Math.floor(center - platformWidth / 2)));
        // Fill every tile covered by the platform with solid cells.
        for (let x = start; x < start + platformWidth; x++) {
          tiles[platformRow][x] = 1;
        }
      }
    }

    return tiles;
  }

  // Return (and lazily build) the tile array for the requested area index.
  function getAreaTiles(areaIndex) {
    if (!areaCache.has(areaIndex)) {
      areaCache.set(areaIndex, generateAreaTiles(areaIndex));
    }
    return areaCache.get(areaIndex);
  }

  // Produce the tile grid for a given raised town area index.
  function generateTownAreaTiles(areaIndex) {
    const tiles = [];
    // Build the base plaza layout row-by-row so the ground is mostly walkable.
    for (let y = 0; y < WORLD_ROWS; y++) {
      const row = [];
      // Populate each column of the current row with walkable space by default.
      for (let x = 0; x < TOWN_AREA_COLS; x++) {
        let value = 0;
        // Keep the perimeter walls solid so players stay inside the town bounds.
        if (y === 0 || y === WORLD_ROWS - 1) {
          value = 1;
        }
        row.push(value);
      }
      tiles.push(row);
    }

    // Carve doorway gaps into the edge walls so exits read clearly at the town borders.
    const exitGapStartRow = WORLD_ROWS - 8;
    const exitGapEndRow = WORLD_ROWS - 3;
    // Only add the left border wall when building the first plaza area.
    if (areaIndex === 0) {
      // Fill the leftmost column with walls while leaving a mid-height gap as an exit cue.
      for (let y = 0; y < WORLD_ROWS; y++) {
        if (y < exitGapStartRow || y > exitGapEndRow) {
          tiles[y][0] = 1;
        }
      }
    }
    // Only add the right border wall when building the final plaza area.
    if (areaIndex === TOWN_AREA_COUNT - 1) {
      // Fill the rightmost column with walls while preserving a doorway opening near the ground.
      for (let y = 0; y < WORLD_ROWS; y++) {
        if (y < exitGapStartRow || y > exitGapEndRow) {
          tiles[y][TOWN_AREA_COLS - 1] = 1;
        }
      }
    }

    // Add interior walls between the left and right town areas while leaving a portal gap between them.
    const portalGapStartRow = WORLD_ROWS - 8;
    const portalGapEndRow = WORLD_ROWS - 3;
    // In the left town area, wall off the right edge except for the portal band so the connector acts as a doorway.
    if (areaIndex === 0) {
      for (let y = 0; y < WORLD_ROWS; y++) {
        if (y < portalGapStartRow || y > portalGapEndRow) {
          tiles[y][TOWN_AREA_COLS - 1] = 1;
        }
      }
    }
    // In the right town area, wall off the left edge except for the matching portal band.
    if (areaIndex === 1) {
      for (let y = 0; y < WORLD_ROWS; y++) {
        if (y < portalGapStartRow || y > portalGapEndRow) {
          tiles[y][0] = 1;
        }
      }
    }

    // Build simple impassable shop buildings around the doorways in each town plaza.
    if (areaIndex === 0 || areaIndex === 1) {
      const doorColumn = TOWN_SHOP_DOOR_COLS[areaIndex] || 0;
      // Center the doorway horizontally under the configured door column.
      const doorLeftCol = Math.max(1, doorColumn - 1);
      const doorRightCol = Math.min(TOWN_AREA_COLS - 2, doorLeftCol + 1);
      // Choose a symmetric building footprint around the doorway.
      const buildingTopRow = 2;
      const buildingBottomRow = TOWN_SHOP_DOOR_VISUAL_ROW_BOTTOM;
      const buildingHalfWidth = 6;
      const buildingCenter = doorColumn;
      const buildingStartCol = Math.max(1, buildingCenter - buildingHalfWidth);
      const buildingEndCol = Math.min(TOWN_AREA_COLS - 2, buildingCenter + buildingHalfWidth);

      for (let y = buildingTopRow; y <= buildingBottomRow; y++) {
        for (let x = buildingStartCol; x <= buildingEndCol; x++) {
          // Carve a vertical doorway gap through the building where the shop door lives.
          const withinDoorCols = x >= doorLeftCol && x <= doorRightCol;
          const withinDoorRows =
            y >= TOWN_SHOP_DOOR_VISUAL_ROW_TOP && y <= TOWN_SHOP_DOOR_VISUAL_ROW_BOTTOM;
          if (withinDoorCols && withinDoorRows) continue;
          tiles[y][x] = 1;
        }
      }
    }

    return tiles;
  }

  // Return (and lazily build) the tile array for the requested raised town area index.
  function getTownAreaTiles(areaIndex) {
    if (!townAreaCache.has(areaIndex)) {
      townAreaCache.set(areaIndex, generateTownAreaTiles(areaIndex));
    }
    return townAreaCache.get(areaIndex);
  }

  // Produce a simple shop interior layout for the requested shop index.
  function generateTownShopAreaTiles(shopIndex) {
    const tiles = [];
    for (let y = 0; y < WORLD_ROWS; y++) {
      const row = [];
      for (let x = 0; x < SHOP_COLS; x++) {
        let value = 0;
        // Solid ceiling.
        if (y === 0) {
          value = 1;
        }
        // Solid side walls to keep Link inside the shop bounds.
        if (x === 0 || x === SHOP_COLS - 1) {
          value = 1;
        }
        // Solid floor everywhere except for the doorway gap at the bottom center.
        if (y === WORLD_ROWS - 1) {
          const exitDoorCenter = Math.floor(SHOP_COLS / 2);
          const inDoorway = x >= exitDoorCenter - 1 && x <= exitDoorCenter + 1;
          if (!inDoorway) {
            value = 1;
          }
        }
        row.push(value);
      }
      tiles.push(row);
    }

    return tiles;
  }

  // Return (and lazily build) the tile array for the requested shop interior index.
  function getTownShopAreaTiles(shopIndex) {
    if (!townShopAreaCache.has(shopIndex)) {
      townShopAreaCache.set(shopIndex, generateTownShopAreaTiles(shopIndex));
    }
    return townShopAreaCache.get(shopIndex);
  }

  // Return the list of area indices that overlap the current camera view (with padding for nearby rooms).
  function getVisibleAreaIndices() {
    const start = Math.floor(cameraX / AREA_WIDTH) - 1;
    const end = Math.floor((cameraX + canvas.width) / AREA_WIDTH) + 1;
    const indices = [];
    // Step through each area index that may appear within or near the viewport so we can activate their entities.
    for (let areaIndex = start; areaIndex <= end; areaIndex++) {
      indices.push(areaIndex);
    }
    return indices;
  }

  // Build an octorok instance positioned at the requested world coordinates.
  function createOctorokAt(x, y) {
    return {
      x,
      y,
      width: TILE_SIZE,
      height: TILE_SIZE,
      vx: 0,
      vy: 0,
      gravity: 0.30,
      maxFall: 8,
      onGround: false,
      jumpSpeed: -3.4,
      hitTimer: 0,
      prevVy: 0,
      shotThisJump: false,
      state: 'waitAfterShot',
      stateTimer: 120,
      idleAnimTimer: 0,
      idleAnimFrame: 0
    };
  }

  // Locate a suitable platform within the requested area so the resident octorok can perch on it.
  function findOctorokSpawn(areaIndex, areaTiles) {
    const platformRow = WORLD_ROWS - 6;
    // Abort when the configured platform row falls outside the world height.
    if (platformRow < 0 || platformRow >= WORLD_ROWS) return null;
    const spans = [];
    let spanStart = -1;
    // Scan the entire row to collect contiguous stretches of solid tiles that represent platforms.
    for (let x = 0; x < AREA_COLS; x++) {
      // Begin tracking a new platform span whenever a floating solid tile appears after empty space.
      if (areaTiles[platformRow][x] === 1 && areaTiles[platformRow + 1][x] === 0) {
        // Start the span at the current column if we are not already tracking one.
        if (spanStart === -1) {
          spanStart = x;
        }
      // Close out the span as soon as we return to air tiles.
      } else if (spanStart !== -1) {
        spans.push({ start: spanStart, end: x - 1 });
        spanStart = -1;
      }
    }
    // Ensure the trailing platform is recorded if the row ends on a solid tile.
    if (spanStart !== -1) {
      spans.push({ start: spanStart, end: AREA_COLS - 1 });
    }
    // Skip spawning if the area has no floating platforms.
    if (spans.length === 0) return null;
    const targetCenter = AREA_COLS / 2;
    let bestSpan = spans[0];
    let smallestDistance = Infinity;
    // Choose the platform whose center sits closest to the area's midpoint so the fight feels balanced.
    for (const span of spans) {
      // Measure how far the current span is from the center so we can keep the closest one.
      const center = (span.start + span.end + 1) / 2;
      const distance = Math.abs(center - targetCenter);
      // Keep whichever span minimizes the distance to the center to reduce travel time.
      if (distance < smallestDistance) {
        smallestDistance = distance;
        bestSpan = span;
      }
    }
    const centerTile = (bestSpan.start + bestSpan.end + 1) / 2;
    const spawnX = areaIndex * AREA_WIDTH + centerTile * TILE_SIZE - TILE_SIZE / 2;
    const spawnY = platformRow * TILE_SIZE - TILE_SIZE;
    return { x: spawnX, y: spawnY };
  }

  // Lazily generate the persistent enemy set that belongs to a specific area index.
  function getAreaEntities(areaIndex) {
    // Build the area's enemies the first time we request them so they persist afterward.
    if (!areaEntities.has(areaIndex)) {
      const tiles = getAreaTiles(areaIndex);
      const spawn = findOctorokSpawn(areaIndex, tiles);
      const octorok = spawn ? createOctorokAt(spawn.x, spawn.y) : null;
      const groundY = (WORLD_ROWS - 2) * TILE_SIZE - TILE_SIZE * 2;
      const knightX = areaIndex * AREA_WIDTH + AREA_WIDTH / 2 - TILE_SIZE / 2;
      const armosKnight = createArmosKnightAt(knightX, groundY);
      areaEntities.set(areaIndex, { octorok, armosKnight });
    }
    return areaEntities.get(areaIndex);
  }

  // Create the spawn layout for the spearmen that patrol a specific town area.
  function townSpearmanSpawns(areaIndex) {
    const facing = areaIndex === 0 ? 1 : -1;
    const shallowDepth = TOWN_GROUND_Z - TILE_SIZE * 1.5;
    const baseDepth = TOWN_GROUND_Z - TILE_SIZE * 0.5;
    const quarterWidth = TOWN_AREA_WIDTH / 4;
    return [
      { x: quarterWidth - TILE_SIZE * 0.5, z: baseDepth, facing },
      { x: quarterWidth * 2, z: shallowDepth, facing },
      { x: quarterWidth * 3 - TILE_SIZE * 0.5, z: baseDepth, facing }
    ];
  }

  // Build the roster of spearmen that belong to the requested town area.
  function createTownSpearmenForArea(areaIndex) {
    const spawns = townSpearmanSpawns(areaIndex);
    const enemies = [];
    // Instantiate one spearman per spawn coordinate so each area hosts three patrols.
    for (const spawn of spawns) {
      enemies.push(createTownSpearmanAt(spawn.x, spawn.z, spawn.facing));
    }
    return enemies;
  }

  // Retrieve (and lazily build) the spearmen assigned to a given town area.
  function getTownSpearmen(areaIndex) {
    if (!townEnemies.has(areaIndex)) {
      townEnemies.set(areaIndex, createTownSpearmenForArea(areaIndex));
    }
    return townEnemies.get(areaIndex);
  }

  // Clear town enemies so the patrol roster resets whenever Link re-enters the plaza.
  function resetTownEnemies() {
    townEnemies.clear();
  }

  // Track the current horizontal scroll position of the camera.
  let cameraX = 0;

  // Update the camera so it stays centered on Link while remaining inside the active area.
  function updateCamera() {
    const areaIndex = Math.floor(player.x / AREA_WIDTH);
    const areaStart = areaIndex * AREA_WIDTH;
    const areaEnd = areaStart + AREA_WIDTH;
    const target = player.x + player.width / 2 - canvas.width / 2;
    const minCam = areaStart;
    const maxCam = areaEnd - canvas.width;
    cameraX = Math.min(Math.max(target, minCam), maxCam);
  }

  // Update the raised-view camera so it follows Link across the fixed-length town strip.
  function updateTownCamera() {
    const target = player.x + player.width / 2 - canvas.width / 2;
    // Clamp the camera within the current area's width so each segment or shop scrolls independently.
    const minCam = 0;
    const activeWidth = townState.inShop ? SHOP_WIDTH : TOWN_AREA_WIDTH;
    const maxCam = Math.max(0, activeWidth - canvas.width);
    cameraX = Math.min(Math.max(target, minCam), maxCam);
  }

  // Duration of the player's walking animation frames in ticks.
  const WALK_ANIM_FRAME_DURATION = 6;
  // Duration of the Octorok's idle animation frames in ticks.
  const OCTOROK_IDLE_FRAME_DURATION = 24;

  // Player properties: 2 tiles tall, 1 tile wide
  const player = {
    x: 4 * TILE_SIZE,
    y: (WORLD_ROWS - 4) * TILE_SIZE,
    z: (WORLD_ROWS - 4) * TILE_SIZE,
    width: TILE_SIZE,
    height: TILE_SIZE * 2,
    standHeight: TILE_SIZE * 2,
    crouchHeight: Math.floor(TILE_SIZE * 1.75),
    vx: 0,
    vy: 0,
    speed: 2.2,
    jumpSpeed: -7,
    gravity: 0.35,
    maxFall: 10,
    onGround: false,
    facing: 1, // 1 right, -1 left
    crouching: false,
    attacking: false,
    attackTimer: 0,
    hitTimer: 0,
    attackWindup: 2,
    attackStab: 6,
    attackRecover: 3,
    blockedThisSwing: false,
    walking: false,
    walkAnimTimer: 0,
    walkAnimFrame: 0,
    get attackDuration() {
      return this.attackWindup + this.attackStab + this.attackRecover;
    }
  };

  // Track contextual data for the raised-view town, including where to return on exit.
  const townState = {
    // Default overworld entry tile used for the very first town visit before any transitions occur.
    entryTile: { x: 17, y: 6 },
    entrySide: 'left',
    // Index of the active town area segment so each plaza behaves like a discrete room.
    areaIndex: 0,
    // When true, Link is inside a shop interior rather than the outdoor plaza.
    inShop: false,
    // Index of the shop interior currently occupied so exits can return to the correct plaza.
    shopIndex: 0
  };

  // Reset Link's side-view pose when returning from the overworld.
  function resetSideViewPlayerPosition() {
    player.x = TILE_SIZE * 2;
    player.y = (WORLD_ROWS - 4) * TILE_SIZE;
    player.z = player.y;
    player.vx = 0;
    player.vy = 0;
    player.onGround = true;
    player.attacking = false;
    player.attackTimer = 0;
    player.blockedThisSwing = false;
    player.crouching = false;
    player.height = player.standHeight;
    cameraX = 0;
    lastAttackPressed = false;
    lastJumpPressed = false;
  }

  // Place Link at the front of the raised-view town while clearing any combat state.
  function resetTownPlayerPosition() {
    // Start near the appropriate entrance within the active town area while keeping coordinates local to that area.
    townState.areaIndex = townState.entrySide === 'right' ? 1 : 0;
    townState.inShop = false;
    player.x = townState.entrySide === 'right'
      ? TOWN_AREA_WIDTH - TILE_SIZE * 3
      : TILE_SIZE * 2;
    player.y = TOWN_GROUND_Z;
    player.z = TOWN_GROUND_Z;
    player.vx = 0;
    player.vy = 0;
    player.onGround = true;
    player.attacking = false;
    player.attackTimer = 0;
    player.blockedThisSwing = false;
    player.crouching = false;
    player.height = player.standHeight;
    player.facing = townState.entrySide === 'right' ? -1 : 1;
    cameraX = 0;
    lastAttackPressed = false;
    lastJumpPressed = false;
  }

  // Compute the tile column of the interior portal doorway for the active town area.
  function currentTownPortalColumn() {
    // Left area uses the rightmost column; right area uses the leftmost column.
    return townState.areaIndex === 0 ? TOWN_AREA_COLS - 1 : 0;
  }

  const rocks = [];
  const particles = [];

  // Input
  const keys = {
    w: false,
    a: false,
    s: false,
    d: false,
    j: false,
    k: false
  };

  const activePointers = new Map();

  // Track whether the attack input was pressed on the previous frame so we can detect single presses.
  let lastAttackPressed = false;
  // Track whether the jump input was pressed on the previous frame so we only trigger a jump on the edge.
  let lastJumpPressed = false;

  // Release buttons that still track a pointer id or clear a specific button entirely.
  function releasePointerFromButtons(pointerId, specificButton) {
    // Iterate over each button that still has one or more active pointers.
    for (const [btn, set] of activePointers.entries()) {
      // Skip buttons that don't match the requested target.
      if (specificButton && btn !== specificButton) continue;
      // Skip buttons that do not contain the pointer we are clearing.
      if (pointerId !== undefined && !set.has(pointerId)) continue;

      // Drop the specific pointer id or clear the entire button when no id is provided.
      if (pointerId !== undefined) {
        set.delete(pointerId);
      } else {
        set.clear();
      }

      // Release the button entirely once no pointers remain associated with it.
      if (set.size === 0) {
        activePointers.delete(btn);
        setKeyState(btn.dataset.key, false);
        btn.classList.remove('active');
      }

      // Exit early after clearing a matching button or pointer id to avoid extra work.
      if (specificButton || pointerId !== undefined) break;
    }
  }

  // Update the stored pressed state for a given virtual key.
  function setKeyState(key, pressed) {
    // Only update keys that are actually tracked to ignore stray inputs.
    if (key in keys) {
      keys[key] = pressed;
    }
  }

  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    // Only react to keys that are part of the control scheme.
    if (k in keys) {
      keys[k] = true;
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    // Only react to keys that are part of the control scheme.
    if (k in keys) {
      keys[k] = false;
      e.preventDefault();
    }
  });

  // Track the most recently used gamepad so we can poll it each frame.
  const gamepadState = {
    activeIndex: null,
    lastId: '',
    deadZone: 0.2,
    hasConnected: false
  };

  // Log basic information whenever a new gamepad connects so mappings can be verified.
  window.addEventListener('gamepadconnected', (e) => {
    const gp = e.gamepad;
    console.log(
      'Gamepad connected at index %d: %s. %d buttons, %d axes.',
      gp.index,
      gp.id,
      gp.buttons.length,
      gp.axes.length
    );
    console.log('Gamepad mapping:', gp.mapping || '(none)');
    gamepadState.activeIndex = gp.index;
    gamepadState.lastId = gp.id || '';
    gamepadState.hasConnected = true;
  });

  // Clear the active index and log a message whenever a gamepad disconnects.
  window.addEventListener('gamepaddisconnected', (e) => {
    const gp = e.gamepad;
    console.log(
      'Gamepad disconnected from index %d: %s',
      gp.index,
      gp.id
    );
    if (gamepadState.activeIndex === gp.index) {
      gamepadState.activeIndex = null;
    }
  });

  // Show a gentle hint if no controller is detected shortly after the game starts.
  const infoElement = document.getElementById('info');
  if (infoElement) {
    setTimeout(() => {
      // Only display the controller hint when no gamepad has ever connected.
      if (!gamepadState.hasConnected) {
        const hint = document.createElement('div');
        hint.textContent = 'Connect a controller or use touch/keyboard.';
        infoElement.appendChild(hint);
      }
    }, 3000);
  }

  // Read the primary gamepad and convert its raw axes/buttons into high-level actions.
  function readGamepadActions() {
    // Abort if the Gamepad API is not available in this browser.
    if (typeof navigator === 'undefined' || typeof navigator.getGamepads !== 'function') {
      return null;
    }

    const gamepads = navigator.getGamepads();
    if (!gamepads) return null;

    let gp = null;

    // Prefer the last active gamepad index while it remains connected.
    if (gamepadState.activeIndex !== null && gamepads[gamepadState.activeIndex]) {
      gp = gamepads[gamepadState.activeIndex];
    }

    // Fallback: scan for the first non-null gamepad slot.
    if (!gp) {
      for (let i = 0; i < gamepads.length; i++) {
        // Skip empty entries so we only consider attached controllers.
        if (gamepads[i]) {
          gp = gamepads[i];
          break;
        }
      }
    }

    // Abort when no connected gamepads are present.
    if (!gp) return null;

    gamepadState.activeIndex = gp.index;
    gamepadState.lastId = gp.id || gamepadState.lastId;
    gamepadState.hasConnected = true;

    const axes = gp.axes || [];
    const buttons = gp.buttons || [];
    const deadZone = gamepadState.deadZone;

    const lx = axes[0] || 0;
    const ly = axes[1] || 0;

    // Suppress minor stick noise so tiny drift does not cause unintended movement.
    const filteredLX = Math.abs(lx) < deadZone ? 0 : lx;
    const filteredLY = Math.abs(ly) < deadZone ? 0 : ly;

    let left = filteredLX < -0.4;
    let right = filteredLX > 0.4;
    let down = filteredLY > 0.4;

    // Blend in d-pad input so digital presses can move and crouch.
    if (buttons[14] && buttons[14].pressed) left = true;
    if (buttons[15] && buttons[15].pressed) right = true;
    if (buttons[13] && buttons[13].pressed) down = true;

    const btnA = buttons[0] && buttons[0].pressed;
    const btnB = buttons[1] && buttons[1].pressed;
    const btnX = buttons[2] && buttons[2].pressed;

    // Map the south face button (A on Xbox / 8BitDo in X-Input mode) to jump.
    const jump = !!btnA;
    // Map X / B style buttons to sword attacks so either face button can strike.
    const attack = !!(btnX || btnB);

    return { left, right, down, jump, attack };
  }

  // Merge keyboard, touch, and gamepad sources into a single virtual key set for gameplay.
  function combinedInputKeys() {
    const pad = readGamepadActions();
    // When no controller is present, fall back to the raw keyboard/touch state.
    if (!pad) {
      return keys;
    }
    return {
      a: keys.a || pad.left,
      d: keys.d || pad.right,
      s: keys.s || pad.down,
      j: keys.j || pad.attack,
      k: keys.k || pad.jump
    };
  }

  const touchControls = document.getElementById('touch-controls');
  // Only enable touch controls if the UI is present.
  if (touchControls) {
    const buttons = touchControls.querySelectorAll('button[data-key]');
    // Iterate over every virtual button so they all receive pointer handlers.
    buttons.forEach((btn) => {
      const key = btn.dataset.key;
      const getPointerSet = () => {
        let set = activePointers.get(btn);
        if (!set) {
          set = new Set();
          activePointers.set(btn, set);
        }
        return set;
      };

      const press = (e) => {
        e.preventDefault();
        btn.setPointerCapture(e.pointerId);
        const set = getPointerSet();
        if (set.has(e.pointerId)) return;
        const wasInactive = set.size === 0;
        set.add(e.pointerId);
        if (wasInactive) {
          setKeyState(key, true);
          btn.classList.add('active');
        }
      };

      const release = (e) => {
        // Guard against synthetic releases without a pointer event object.
        if (e) e.preventDefault();
        releasePointerFromButtons(e ? e.pointerId : undefined, btn);
      };

      btn.addEventListener('pointerdown', press);
      btn.addEventListener('pointerup', release);
      btn.addEventListener('pointercancel', release);
    });
    // Ensure keys release if pointer leaves the browser viewport entirely.
    window.addEventListener('pointerup', (e) => {
      // Release whichever button was tracking this pointer id.
      releasePointerFromButtons(e.pointerId);
    });
    window.addEventListener('pointercancel', (e) => {
      // Release any button associated with a cancelled pointer gesture.
      releasePointerFromButtons(e.pointerId);
    });
    window.addEventListener('blur', () => {
      // Clear every button when the tab loses focus to avoid stuck inputs.
      releasePointerFromButtons();
    });
  }

  // Initialize the overworld module now that the shared tile size is known.
  initOverworld(TILE_SIZE);

  // Look up the tile index inside the raised-view town at the requested tile coordinate.
  function townTileAtTileCoordinates(tileX, tileY) {
    // Treat vertical out-of-bounds as solid so Link cannot leave the plaza height.
    if (tileY < 0 || tileY >= WORLD_ROWS) return 1;
    // Treat horizontal out-of-bounds as solid so Link cannot walk beyond the local plaza/shop width.
    const maxCols = townState.inShop ? SHOP_COLS : TOWN_AREA_COLS;
    if (tileX < 0 || tileX >= maxCols) return 1;
    // Resolve tiles from either the outdoor plaza or the current shop interior.
    const areaTiles = townState.inShop
      ? getTownShopAreaTiles(townState.shopIndex || 0)
      : getTownAreaTiles(townState.areaIndex || 0);
    return areaTiles[tileY][tileX];
  }

  // Look up the tile index inside the raised-view town at the requested pixel coordinate.
  function townTileAtPixel(x, y) {
    const tx = Math.floor(x / TILE_SIZE);
    const ty = Math.floor(y / TILE_SIZE);
    return townTileAtTileCoordinates(tx, ty);
  }

  // Look up the tile index that occupies the given tile coordinate across any area.
  function tileAtTileCoordinates(tileX, tileY) {
    if (tileY < 0 || tileY >= WORLD_ROWS) return 1;
    const areaIndex = Math.floor(tileX / AREA_COLS);
    const localTileX = tileX - areaIndex * AREA_COLS;
    const areaTiles = getAreaTiles(areaIndex);
    if (localTileX < 0 || localTileX >= AREA_COLS) return 1;
    return areaTiles[tileY][localTileX];
  }

  // Look up the tile index that occupies the given pixel coordinate.
  function tileAtPixel(x, y) {
    const tx = Math.floor(x / TILE_SIZE);
    const ty = Math.floor(y / TILE_SIZE);
    return tileAtTileCoordinates(tx, ty);
  }

  // Determine whether a rectangle collides with any solid world tiles.
  function rectVsWorld(x, y, width, height) {
    // Check multiple points along the edges so we don't slip into tiles from the side
    const left = x;
    const right = x + width;
    const top = y;
    const bottom = y + height;
    const midY = (top + bottom) / 2;

    // Abort when the top-left corner hits something solid.
    if (tileAtPixel(left, top)) return true;
    // Abort when the top-right corner hits something solid.
    if (tileAtPixel(right - 1, top)) return true;
    // Abort when the mid-left sample hits something solid.
    if (tileAtPixel(left, midY)) return true;
    // Abort when the mid-right sample hits something solid.
    if (tileAtPixel(right - 1, midY)) return true;
    // Abort when the bottom-left corner hits something solid.
    if (tileAtPixel(left, bottom - 1)) return true;
    // Abort when the bottom-right corner hits something solid.
    if (tileAtPixel(right - 1, bottom - 1)) return true;
    return false;
  }

  // Determine whether a rectangle collides with any solid town tiles.
  function townRectVsWorld(x, z, width, height) {
    const left = x;
    const right = x + width;
    const top = z;
    const bottom = z + height;
    const midZ = (top + bottom) / 2;

    // Abort when the top-left corner hits something solid.
    if (townTileAtPixel(left, top)) return true;
    // Abort when the top-right corner hits something solid.
    if (townTileAtPixel(right - 1, top)) return true;
    // Abort when the mid-left sample hits something solid.
    if (townTileAtPixel(left, midZ)) return true;
    // Abort when the mid-right sample hits something solid.
    if (townTileAtPixel(right - 1, midZ)) return true;
    // Abort when the bottom-left corner hits something solid.
    if (townTileAtPixel(left, bottom - 1)) return true;
    // Abort when the bottom-right corner hits something solid.
    if (townTileAtPixel(right - 1, bottom - 1)) return true;
    return false;
  }

  // Track debug information for the raised-view town connectors so it can be drawn on screen.
  let debugTownConnectorInfo = '';

  // Build the sword's collision box when Link is in the stab phase of his attack.
  function swordHitbox() {
    // Skip collision while no attack is in progress.
    if (!player.attacking) return null;
    const t = player.attackTimer;
    // Only show the sword hitbox during the active stab frames.
    if (t < player.attackWindup || t >= player.attackWindup + player.attackStab) return null;

    // Match the main stab phase sword position roughly
    const swordLength = TILE_SIZE;
    const swordWidth = 4;
    const x = player.facing > 0 ? player.x + player.width : player.x - swordLength;
    // Lift the standing stab slightly so it can clear low shields.
    const standingSwordYOffset = TILE_SIZE - swordWidth - 2;
    const baseOffset = player.crouching ? player.height - TILE_SIZE / 2 : standingSwordYOffset;
    const y = player.y + baseOffset;
    return { x, y, width: swordLength, height: swordWidth };
  }

  // Perform a simple AABB overlap check.
  function rectsOverlap(a, b) {
    return !(
      a.x + a.width <= b.x ||
      a.x >= b.x + b.width ||
      a.y + a.height <= b.y ||
      a.y >= b.y + b.height
    );
  }

  // Compute the player's shield hitbox, accounting for crouching and facing.
  function shieldHitbox() {
    const shieldWidth = TILE_SIZE * 0.6;
    const shieldHeight = TILE_SIZE;
    let shieldY;
    // Anchor the shield lower while crouching so it covers Link's knees.
    if (player.crouching) {
      shieldY = player.y + player.height - shieldHeight;
    } else {
      shieldY = player.y + TILE_SIZE * 0.2;
    }
    let shieldX;
    // Offset the shield based on facing so it always sits in front of Link.
    if (player.facing > 0) {
      shieldX = player.x + player.width - shieldWidth + 1;
    } else {
      shieldX = player.x - 1;
    }
    return {
      x: shieldX,
      y: shieldY,
      width: shieldWidth,
      height: shieldHeight
    };
  }

  // Handle player input, physics, combat, and reactions to damage.
  function updatePlayer() {
    // Pull together keyboard, touch, and controller state so gameplay reads from one source.
    const inputKeys = combinedInputKeys();

    // Detect a fresh press of the attack button so holding it down does not chain multiple swings.
    const attackJustPressed = inputKeys.j && !lastAttackPressed;
    // Detect a fresh press of the jump button so holding it down does not trigger repeated jumps.
    const jumpJustPressed = inputKeys.k && !lastJumpPressed;

    // Horizontal input (used for facing even while attacking)
    let inputDir = 0;
    // Tilt left when the virtual left input is held down.
    if (inputKeys.a) inputDir -= 1;
    // Tilt right when the virtual right input is held down.
    if (inputKeys.d) inputDir += 1;

    const lockMovement = (player.attacking && player.onGround) || player.hitTimer > 0;
    const moveX = lockMovement ? 0 : inputDir;

    // Crouch (S) can be used on ground or in air,
    // but you can't change crouch state during an attack
    const wasCrouching = player.crouching;
    // Allow crouch toggles only when not attacking or flinching.
    if (!player.attacking && player.hitTimer === 0) {
      player.crouching = inputKeys.s;
    }

    // Adjust collision box when crouching / standing
    if (player.crouching !== wasCrouching) {
      // Shrink the player's collider whenever crouching begins.
      if (player.crouching) {
        const delta = player.standHeight - player.crouchHeight;
        player.y += delta;
        player.height = player.crouchHeight;
      // Try to return to full height if the crouch is released.
      } else {
        const delta = player.standHeight - player.crouchHeight;
        const newY = player.y - delta;
        // Only stand up if there is room
        if (!rectVsWorld(player.x, newY, player.width, player.standHeight)) {
          player.y = newY;
          player.height = player.standHeight;
        } else {
          // Stay crouched if overhead terrain blocks the stand-up attempt.
          player.crouching = true;
        }
      }
    }

    // Facing direction (ignore zero movement)
    if (inputDir !== 0) {
      player.facing = inputDir > 0 ? 1 : -1;
    }

    // Apply horizontal velocity (no air control damping)
    // During hit-stun, preserve knockback velocity instead of overriding it
    // Only override movement while Link is not recoiling from damage.
    if (player.hitTimer === 0) {
      player.vx = moveX * player.speed;
    }

    // Jump (virtual K)
    // Trigger a jump only when the virtual jump button transitions from up to down while grounded and free to move.
    if (jumpJustPressed && player.onGround && !player.attacking && player.hitTimer === 0) {
      player.vy = player.jumpSpeed;
      player.onGround = false;
    }

    // Gravity
    player.vy += player.gravity;
    // Prevent falling speed from exceeding the cap.
    if (player.vy > player.maxFall) player.vy = player.maxFall;

    // Horizontal collision
    let newX = player.x + player.vx;
    // Slide freely when the path ahead is clear.
    if (!rectVsWorld(newX, player.y, player.width, player.height)) {
      player.x = newX;
    } else {
      // slide
      // Walk pixel-by-pixel into the wall to land flush without overlapping.
      while (!rectVsWorld(player.x + Math.sign(player.vx), player.y, player.width, player.height)) {
        player.x += Math.sign(player.vx);
      }
      player.vx = 0;
    }

    // Vertical collision
    let newY = player.y + player.vy;
    // Allow freefall whenever the new position is unobstructed.
    if (!rectVsWorld(player.x, newY, player.width, player.height)) {
      player.y = newY;
      player.onGround = false;
    } else {
      // Handle downward impacts differently from upward hits.
      if (player.vy > 0) {
        // Landing on ground
        // Step downward until feet touch the floor to avoid sinking.
        while (!rectVsWorld(player.x, player.y + 1, player.width, player.height)) {
          player.y += 1;
        }
        player.onGround = true;
      } else if (player.vy < 0) {
        // Hitting ceiling
        // Step upward until the head clears to keep the body outside tiles.
        while (!rectVsWorld(player.x, player.y - 1, player.width, player.height)) {
          player.y -= 1;
        }
      }
      player.vy = 0;
    }

    // Attack (virtual J) - standing or crouching allowed
    // Start a new stab only when the attack button transitions from up to down and Link is free to act.
    if (attackJustPressed && !player.attacking && player.hitTimer === 0) {
      player.attacking = true;
      player.attackTimer = 0;
      player.blockedThisSwing = false;
    }

    // Count through the attack animation frames.
    if (player.attacking) {
      player.attackTimer++;
      // End the attack when the animation timer completes.
      if (player.attackTimer >= player.attackDuration) {
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }

    // Taper off hurt invulnerability each frame until it hits zero.
    if (player.hitTimer > 0) {
      player.hitTimer--;
    }

    // Determine whether Link is currently walking so the animation can advance.
    const currentlyWalking =
      player.onGround &&
      Math.abs(player.vx) > 0.1 &&
      !player.crouching &&
      player.hitTimer === 0 &&
      !player.attacking;
    player.walking = currentlyWalking;
    // Update the walking animation timer/frame whenever movement is happening.
    if (currentlyWalking) {
      player.walkAnimTimer++;
      // Swap frames every few ticks to create a two-step cycle.
      if (player.walkAnimTimer >= WALK_ANIM_FRAME_DURATION) {
        player.walkAnimTimer = 0;
        player.walkAnimFrame = (player.walkAnimFrame + 1) % 2;
      }
    } else {
      // Reset the walk animation when standing still so it starts from frame 0.
      player.walkAnimTimer = 0;
      player.walkAnimFrame = 0;
    }

    // Remember whether the attack and jump inputs are held for the next frame so we can continue to detect edge presses.
    lastAttackPressed = inputKeys.j;
    lastJumpPressed = inputKeys.k;

  }

  // Handle free movement inside the raised-view town where up/down map to depth while jumps lift vertically.
  function updateRaisedPlayer() {
    const inputKeys = combinedInputKeys();

    // Detect a fresh press of the attack button so holding it down does not chain multiple swings.
    const attackJustPressed = inputKeys.j && !lastAttackPressed;
    // Detect a fresh jump press so the leap only fires once per key edge.
    const jumpJustPressed = inputKeys.k && !lastJumpPressed;

    // Compute directional intent using both axes so Link can walk diagonally across the plaza.
    let moveX = 0;
    let moveZ = 0;
    // Honor leftward input by subtracting from the horizontal axis.
    if (inputKeys.a) moveX -= 1;
    // Honor rightward input by adding to the horizontal axis.
    if (inputKeys.d) moveX += 1;
    // Honor upward input by subtracting from the depth axis to walk away from the camera while grounded.
    if (player.onGround && inputKeys.w) moveZ -= 1;
    // Honor downward input by adding to the depth axis to walk toward the camera while grounded.
    if (player.onGround && inputKeys.s) moveZ += 1;
    // Mirror the side-view rule by freezing movement during ground attacks and hitstun so Link cannot walk while swinging.
    if ((player.attacking && player.onGround) || player.hitTimer > 0) {
      moveX = 0;
      moveZ = 0;
    }

    // Normalize diagonal walks so pace remains consistent in every direction.
    const magnitude = Math.hypot(moveX, moveZ);
    const moveScale = magnitude > 0 ? player.speed / magnitude : 0;
    const scaledMoveX = moveX * moveScale;
    const scaledMoveZ = moveZ * moveScale;

    // Turn to face the most recent horizontal input while leaving vertical strafe unchanged.
    if (moveX !== 0) {
      player.facing = moveX > 0 ? 1 : -1;
    }

    // Keep combat state simple by disabling crouch in the raised view.
    player.crouching = false;
    player.height = player.standHeight;

    // Trigger a leap while grounded so the jump arc does not chain repeatedly.
    if (jumpJustPressed && player.onGround && !player.attacking && player.hitTimer === 0) {
      player.onGround = false;
      player.vy = player.jumpSpeed;
    }

    // Apply gravity and vertical movement when airborne while keeping depth locked.
    if (!player.onGround) {
      player.vy = Math.min(player.vy + player.gravity, player.maxFall);
      player.y += player.vy;
      // Snap back to the ground plane when the jump arc finishes.
      if (player.y >= player.z) {
        player.y = player.z;
        player.vy = 0;
        player.onGround = true;
      }
    } else {
      player.vy = 0;
      player.y = player.z;
    }

    const proposedX = player.x + scaledMoveX;
    const proposedZ = player.z + scaledMoveZ;
    // Track the intended horizontal position so we can reroute exits without losing the original intent.
    let adjustedX = proposedX;

    if (!townState.inShop) {
      // Exit back to the overworld once Link walks beyond the outer edges of the active plaza strip.
      // When standing in the left town area, walking past the far left border leaves to the overworld.
      if (adjustedX < 0) {
        if (townState.areaIndex === 0) {
          returnToOverworldFromTown('left');
          return true;
        } else {
          // Clamp against the left wall of the right town area so only the connector can move us back.
          adjustedX = 0;
        }
      }
      // When standing in the right town area, walking past the far right border leaves to the overworld.
      if (adjustedX + player.width > TOWN_AREA_WIDTH) {
        if (townState.areaIndex === 1) {
          returnToOverworldFromTown('right');
          return true;
        } else {
          // Clamp against the right wall of the left town area so the connector handles transitions instead.
          adjustedX = TOWN_AREA_WIDTH - player.width;
        }
      }

      // Teleport across town whenever Link walks through the interior doorway at the edge of the current town area.
      const nextMidX = adjustedX + player.width / 2;
      const nextMidZ = proposedZ + player.height / 2;
      const midTileX = Math.floor(nextMidX / TILE_SIZE);
      const midTileZ = Math.floor(nextMidZ / TILE_SIZE);
      // Match the interior wall gap we carved into the town tiles.
      const portalGapStartRow = WORLD_ROWS - 8;
      const portalGapEndRow = WORLD_ROWS - 3;
      const portalColumn = currentTownPortalColumn();
      const withinPortalBand = midTileZ >= portalGapStartRow && midTileZ <= portalGapEndRow;
      const atPortalColumn = midTileX === portalColumn;
      const destinationTownArea = townState.areaIndex === 0 ? 1 : 0;
      const centerOffset = TOWN_AREA_WIDTH / 2;
      // Warp across town whenever Link's midpoint passes through the interior doorway band.
      if (atPortalColumn && withinPortalBand) {
        // Flip to the opposite town area and drop Link just inside its entrance edge using local coordinates.
        townState.areaIndex = destinationTownArea;
        const enteringFromLeft = townState.areaIndex === 0;
        player.x = enteringFromLeft
          ? TOWN_AREA_WIDTH - TILE_SIZE * 3
          : TILE_SIZE * 2;
        player.z = TOWN_GROUND_Z;
        player.y = player.z;
        player.vx = 0;
        player.vy = 0;
        return false;
      }

      // Enter a shop interior when standing inside the visible doorway and pressing up.
      const doorColumn = TOWN_SHOP_DOOR_COLS[townState.areaIndex] || 0;
      const doorWorldX = (doorColumn - 1) * TILE_SIZE;
      const doorWidth = TILE_SIZE * 2;
      const doorLeft = doorWorldX;
      const doorRight = doorWorldX + doorWidth;
      const doorTop = TOWN_SHOP_DOOR_VISUAL_ROW_TOP * TILE_SIZE;
      const doorBottom = (TOWN_SHOP_DOOR_VISUAL_ROW_BOTTOM + 1) * TILE_SIZE;
      const playerCenterX = player.x + player.width / 2;
      const playerFeetY = player.y + player.height;
      const playerHeadY = player.y;
      const overlapsDoorX = playerCenterX >= doorLeft && playerCenterX <= doorRight;
      const overlapsDoorY = playerFeetY >= doorTop && playerHeadY <= doorBottom;
      if (
        overlapsDoorX &&
        overlapsDoorY &&
        inputKeys.w &&
        player.onGround &&
        !player.attacking &&
        player.hitTimer === 0
      ) {
        townState.inShop = true;
        townState.shopIndex = townState.areaIndex;
        // Place Link just inside the interior doorway so he appears close to the entrance.
        const exitDoorCenter = Math.floor(SHOP_COLS / 2);
        player.x = exitDoorCenter * TILE_SIZE - player.width / 2;
        player.z = TOWN_GROUND_Z;
        player.y = player.z;
        player.vx = 0;
        player.vy = 0;
        return false;
      }
    } else {
      // Inside a shop: allow exiting back to the plaza through a bottom doorway band when pressing down.
      const midX = player.x + player.width / 2;
      const midZ = player.z + player.height / 2;
      const tileX = Math.floor(midX / TILE_SIZE);
      const tileZ = Math.floor(midZ / TILE_SIZE);
      const exitBandTop = WORLD_ROWS - 3;
      const exitBandBottom = WORLD_ROWS - 1;
      const exitDoorCenter = Math.floor(SHOP_COLS / 2);
      const atExitColumn =
        tileX >= exitDoorCenter - 1 && tileX <= exitDoorCenter + 1;
      const inExitBand = tileZ >= exitBandTop && tileZ <= exitBandBottom;
      if (
        atExitColumn &&
        inExitBand &&
        inputKeys.s &&
        player.onGround &&
        !player.attacking &&
        player.hitTimer === 0
      ) {
        townState.inShop = false;
        townState.areaIndex = townState.shopIndex || 0;
        // Place Link just outside the shop door back on the plaza, centered in the doorway gap.
        const doorColumn = TOWN_SHOP_DOOR_COLS[townState.areaIndex] || 0;
        player.x = doorColumn * TILE_SIZE - player.width / 2;
        // Drop Link onto a depth row just in front of the building so he appears close to the exterior doorway.
        const doorRowJustBelow = TOWN_SHOP_DOOR_VISUAL_ROW_BOTTOM + 1;
        player.z = doorRowJustBelow * TILE_SIZE;
        player.y = player.z;
        player.vx = 0;
        player.vy = 0;
        return false;
      }

    }

    // Apply horizontal movement only when the path stays clear of buildings.
    if (!townRectVsWorld(adjustedX, player.z, player.width, player.height)) {
      player.x = adjustedX;
    }
    // Apply depth movement only when the path stays clear of scenery and the player is grounded.
    if (!townRectVsWorld(player.x, proposedZ, player.width, player.height)) {
      player.z = proposedZ;
      if (player.onGround) {
        player.y = player.z;
      }
    }

    // Attack (virtual J) - available for timing practice even without enemies.
    if (attackJustPressed && !player.attacking && player.hitTimer === 0) {
      player.attacking = true;
      player.attackTimer = 0;
      player.blockedThisSwing = false;
    }

    // Count through the attack animation frames when active.
    if (player.attacking) {
      player.attackTimer++;
      // End the attack when the animation timer completes.
      if (player.attackTimer >= player.attackDuration) {
        player.attacking = false;
        player.attackTimer = 0;
        player.blockedThisSwing = false;
      }
    }

    // Taper off hurt invulnerability each frame until it hits zero.
    if (player.hitTimer > 0) {
      player.hitTimer--;
    }

    // Determine whether Link is currently walking so the animation can advance.
    const currentlyWalking =
      (Math.abs(scaledMoveX) > 0.05 || Math.abs(scaledMoveZ) > 0.05) &&
      player.hitTimer === 0 &&
      !player.attacking;
    player.walking = currentlyWalking;
    // Update the walking animation timer/frame whenever movement is happening.
    if (currentlyWalking) {
      player.walkAnimTimer++;
      // Swap frames every few ticks to create a two-step cycle.
      if (player.walkAnimTimer >= WALK_ANIM_FRAME_DURATION) {
        player.walkAnimTimer = 0;
        player.walkAnimFrame = (player.walkAnimFrame + 1) % 2;
      }
    } else {
      // Reset the walk animation when standing still so it starts from frame 0.
      player.walkAnimTimer = 0;
      player.walkAnimFrame = 0;
    }

    // Remember whether the attack and jump inputs are held for the next frame so we can continue to detect edge presses.
    lastAttackPressed = inputKeys.j;
    lastJumpPressed = inputKeys.k;

    return false;
  }

  // Render the tile-based ground layout relative to the camera.
  function drawWorld() {
    const startTileX = Math.floor(cameraX / TILE_SIZE);
    const endTileX = Math.floor((cameraX + canvas.width) / TILE_SIZE) + 1;
    // Walk each row in the playfield so we can render any visible tiles.
    for (let y = 0; y < WORLD_ROWS; y++) {
      // Inspect every column that overlaps the current viewport.
      for (let tileX = startTileX; tileX <= endTileX; tileX++) {
        if (tileAtTileCoordinates(tileX, y) === 1) {
          const drawX = tileX * TILE_SIZE - cameraX;
          ctx.fillStyle = '#303060';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = '#505090';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, 4);
        }
      }
    }
  }

  // Render the raised-view town tiles relative to the current camera offset.
  function drawTownWorld() {
    const startTileX = Math.floor(cameraX / TILE_SIZE);
    const endTileX = Math.floor((cameraX + canvas.width) / TILE_SIZE) + 1;
    // Walk each row in the plaza or shop so we can render any visible scenery tiles for the active area.
    for (let y = 0; y < WORLD_ROWS; y++) {
      // Inspect every column that overlaps the current viewport, clamped to the local area width.
      const maxCols = townState.inShop ? SHOP_COLS : TOWN_AREA_COLS;
      for (let tileX = startTileX; tileX <= endTileX && tileX < maxCols; tileX++) {
        // Render only the solid scenery tiles while skipping open floor.
        if (townTileAtTileCoordinates(tileX, y) === 1) {
          const drawX = tileX * TILE_SIZE - cameraX;
          // Tint the scenery differently for each town area so it is obvious which segment Link currently occupies.
          // When inside a shop, reuse the wall colors from the plaza that the shop belongs to.
          const sourceAreaIndex = townState.inShop ? (townState.shopIndex || 0) : townState.areaIndex;
          const isLeftTownSegment = sourceAreaIndex === 0;
          ctx.fillStyle = isLeftTownSegment ? '#2e2e52' : '#3a2048';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.fillStyle = isLeftTownSegment ? '#5a628a' : '#b86ad7';
          ctx.fillRect(drawX, y * TILE_SIZE, TILE_SIZE, 4);
        }
      }
    }
    // Draw the active shop entrance as an obvious black doorway box when standing in the outdoor plaza.
    if (!townState.inShop) {
      const doorColumn = TOWN_SHOP_DOOR_COLS[townState.areaIndex] || 0;
      // Visual doorway sits on the building facade, but its interaction band still lives near Link's depth.
      // Treat the configured door column as the doorway's center so the black box can sit inside the building span.
      const doorX = (doorColumn - 1) * TILE_SIZE - cameraX;
      const doorY = TOWN_SHOP_DOOR_VISUAL_ROW_TOP * TILE_SIZE;
      const doorHeight = (TOWN_SHOP_DOOR_VISUAL_ROW_BOTTOM - TOWN_SHOP_DOOR_VISUAL_ROW_TOP + 1) * TILE_SIZE;
      ctx.fillStyle = '#000000';
      ctx.fillRect(Math.floor(doorX), Math.floor(doorY), TILE_SIZE * 2, doorHeight);
    }
    // Render connector debug info so we can inspect how segments resolve in real time.
    if (debugTownConnectorInfo) {
      ctx.fillStyle = '#ff8080';
      ctx.font = '10px monospace';
      ctx.fillText(debugTownConnectorInfo, 8, 12);
    }
  }

  // Draw the octorok enemy with its simple animation cues.
  function drawOctorok(octorok) {
    const x = Math.floor(octorok.x - cameraX);
    const y = Math.floor(octorok.y);
    const w = octorok.width;
    const h = octorok.height;
    // Compute the small bobbing offset used by the idle animation.
    const bobOffset = octorok.idleAnimFrame === 0 ? 0 : 1;
    // Compute how far the tentacles lift to create a two-frame cycle.
    const tentacleLift = octorok.idleAnimFrame === 0 ? 0 : 2;

    // Flash when hit
    if (octorok.hitTimer > 0 && (octorok.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#ff7040';
    }
    ctx.fillRect(x, y + bobOffset, w, h - bobOffset);

    // Simple eyes
    ctx.fillStyle = '#000000';
    // Offset the eyes upward during the lifted frame so the whole sprite moves.
    const eyeY = y + 4 + bobOffset - (octorok.idleAnimFrame === 0 ? 0 : 1);
    ctx.fillRect(x + 3, eyeY, 3, 3);
    ctx.fillRect(x + w - 6, eyeY, 3, 3);

    // Little mouth on its left side
    ctx.fillStyle = '#602020';
    const mouthWidth = 4;
    const mouthHeight = 3;
    const mouthX = x - 1;
    const mouthY = y + h / 2 - mouthHeight / 2 + bobOffset;
    ctx.fillRect(Math.floor(mouthX), Math.floor(mouthY), mouthWidth, mouthHeight);

    // Animated tentacles that alternate height every other frame.
    ctx.fillStyle = '#ff905c';
    const tentacleY = y + h - 3 - tentacleLift + bobOffset;
    ctx.fillRect(x, tentacleY, w, 3);
  }

  // Render the Armos Knight along with its shield and sword indicators.
  function drawArmosKnight(knight) {
    const renderX = Math.floor(knight.x - cameraX);
    const renderY = Math.floor(knight.y);
    const w = knight.width;
    const h = knight.height;

    // Flash white while in hitstun to provide quick feedback.
    if (knight.hitTimer > 0 && (knight.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#a04040';
    }
    ctx.fillRect(renderX, renderY, w, h);

    // Draw a darker trim to hint at armor plating.
    ctx.fillStyle = '#702828';
    ctx.fillRect(renderX, renderY, w, 4);
    ctx.fillRect(renderX, renderY + h - 4, w, 4);

    // Simple footfalls that alternate height while walking.
    const footHeight = 4;
    const footBaseY = renderY + h - footHeight;
    const legWidth = Math.floor(w / 2);
    const leftLift = knight.walking && knight.walkAnimFrame === 0 ? 2 : 0;
    const rightLift = knight.walking && knight.walkAnimFrame === 1 ? 2 : 0;
    ctx.fillStyle = '#651a1a';
    ctx.fillRect(renderX, footBaseY - leftLift, legWidth, footHeight);
    ctx.fillRect(renderX + legWidth, footBaseY - rightLift, w - legWidth, footHeight);

    // Depict the helmet with a lighter band.
    ctx.fillStyle = '#d89060';
    ctx.fillRect(renderX, renderY, w, Math.floor(TILE_SIZE / 2));

    const shield = knightShieldHitbox(knight);
    ctx.fillStyle = '#c4c8d8';
    ctx.fillRect(Math.floor(shield.x - cameraX), Math.floor(shield.y), shield.width, shield.height);
    ctx.fillStyle = '#8a8fa8';
    ctx.fillRect(Math.floor(shield.x - cameraX) + 1, Math.floor(shield.y) + 2, shield.width - 2, shield.height - 4);

    const swordPose = knightSwordPose(knight);
    // Only draw the sword when the animation is active.
    if (swordPose) {
      const { rect, phase } = swordPose;
      const swordScreenX = Math.floor(rect.x - cameraX);
      const swordScreenY = Math.floor(rect.y);
      ctx.fillStyle = phase === 'windup' ? '#ffd480' : '#f0f0f0';
      ctx.fillRect(swordScreenX, swordScreenY, rect.width, rect.height);
      // Add a subtle glow during the windup so players can spot the upcoming strike.
      if (phase === 'windup') {
        ctx.fillStyle = 'rgba(255, 215, 130, 0.35)';
        ctx.fillRect(swordScreenX - 1, swordScreenY - 1, rect.width + 2, rect.height + 2);
      }
      ctx.fillStyle = '#c8a060';
      const hiltX = knight.facing > 0
        ? Math.floor(knight.x + knight.width - cameraX)
        : Math.floor(knight.x - 6 - cameraX);
      ctx.fillRect(hiltX, swordScreenY - 2, 6, 2);
    }
  }

  // Render the player character, including sword and shield.
  function drawPlayer() {
    const renderX = Math.floor(player.x - cameraX);
    const renderY = Math.floor(player.y);

    // Base body color (flash when hit)
    if (player.hitTimer > 0 && (player.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#2f9e44';
    }

    // Body (simple rectangle)
    ctx.fillRect(renderX, renderY, player.width, player.height);

    // Head (top section)
    const headHeight = Math.min(TILE_SIZE, player.height);
    if (player.hitTimer > 0 && (player.hitTimer % 4 < 2)) {
      ctx.fillStyle = '#ffffff';
    } else {
      ctx.fillStyle = '#ffe6a0';
    }
    ctx.fillRect(renderX, renderY, player.width, headHeight);

    // Simple helmet / hair band
    ctx.fillStyle = '#40a040';
    ctx.fillRect(renderX, renderY, player.width, 4);

    // Draw the feet with a tiny two-frame walking cycle.
    const footHeight = 4;
    const footBaseY = Math.floor(player.y + player.height - footHeight);
    const legWidth = Math.floor(player.width / 2);
    // Lift the left leg during the first walk frame.
    const leftLift = player.walking && player.walkAnimFrame === 0 ? 2 : 0;
    // Lift the right leg during the second walk frame.
    const rightLift = player.walking && player.walkAnimFrame === 1 ? 2 : 0;
    ctx.fillStyle = '#1f6e32';
    // Left foot rectangle that raises when the leg lifts.
    ctx.fillRect(renderX, footBaseY - leftLift, legWidth, footHeight);
    // Right foot rectangle that raises during its corresponding frame.
    ctx.fillRect(Math.floor(player.x + legWidth - cameraX), footBaseY - rightLift, player.width - legWidth, footHeight);

    // Shield (position depends on crouch / stand)
    const sBox = shieldHitbox();
    ctx.fillStyle = '#b0c0ff';
    ctx.fillRect(Math.floor(sBox.x - cameraX), Math.floor(sBox.y), sBox.width, sBox.height);
    ctx.fillStyle = '#8090d0';
    ctx.fillRect(Math.floor(sBox.x - cameraX) + 1, Math.floor(sBox.y) + 2, sBox.width - 2, sBox.height - 4);

    // Sword stab
    if (player.attacking) {
      const t = player.attackTimer;
      let phase = 'recover';
      // Treat early frames as the windup phase.
      if (t < player.attackWindup) {
        phase = 'windup';
      // Treat middle frames as the thrusting phase.
      } else if (t < player.attackWindup + player.attackStab) {
        phase = 'stab';
      }

      // Length / offset by phase
      let swordLength = TILE_SIZE;
      let forwardAdjust = 0;
      // Shorten and retract the blade during the windup.
      if (phase === 'windup') {
        swordLength = TILE_SIZE / 2;
        forwardAdjust = -swordLength / 2;
      // Shorten again while recovering to mimic pulling back.
      } else if (phase === 'recover') {
        swordLength = TILE_SIZE / 2;
        forwardAdjust = -swordLength / 4;
      }

      ctx.fillStyle = '#f8f8f8';
      const swordWidth = 4;
      const swordX = player.facing > 0
        ? player.x + player.width + forwardAdjust
        : player.x - swordLength - forwardAdjust;
      // Lower sword when crouching
      // Use the same lifted offset as the hitbox so visuals and logic align.
      const standingSwordYOffset = TILE_SIZE - swordWidth - 2;
      const baseOffset = player.crouching ? player.height - TILE_SIZE / 2 : standingSwordYOffset;
      const swordY = player.y + baseOffset;
      ctx.fillRect(Math.floor(swordX - cameraX), Math.floor(swordY), swordLength, swordWidth);

      // Hilt
      ctx.fillStyle = '#c8a060';
      const hiltX = player.facing > 0
        ? swordX - 3
        : swordX + swordLength - 1;
      ctx.fillRect(Math.floor(hiltX - cameraX), Math.floor(swordY - 2), 6, 2);
    }
  }

  // Run one frame of the side-scrolling engine, including physics, AI, and rendering.
  function runSideScrollFrame() {
    updatePlayer();
    // Swap to the overworld as soon as Link leaves the starting room to the left.
    if (player.x < -TILE_SIZE / 2) {
      enterOverworldFromSideView();
      return;
    }
    updateCamera();

    const visibleAreas = getVisibleAreaIndices();
    const activeOctoroks = [];
    const activeKnights = [];
    // Gather the enemies that belong to every area visible in or near the camera.
    for (const areaIndex of visibleAreas) {
      const entities = getAreaEntities(areaIndex);
      // Track the area's octorok if it exists so we can update and render it.
      if (entities.octorok) {
        activeOctoroks.push(entities.octorok);
      }
      // Every area includes an Armos Knight, so store the reference for later use.
      if (entities.armosKnight) {
        activeKnights.push(entities.armosKnight);
      }
    }

    // Update each visible octorok before checking for collisions.
    for (const enemy of activeOctoroks) {
      updateOctorok(enemy);
      handleOctorokPlayerInteractions(enemy);
    }

    // Advance each Armos Knight's AI and resolve its interactions with Link.
    for (const knight of activeKnights) {
      updateArmosKnight(knight);
      handleArmosKnightVsPlayer(knight);
    }

    updateRocksAndParticles();

    // Clear
    ctx.fillStyle = '#202048';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawWorld();
    drawPlayer();

    // Render each active octorok.
    for (const enemy of activeOctoroks) {
      drawOctorok(enemy);
    }

    // Render the knights after the player so their swords overlap correctly.
    for (const knight of activeKnights) {
      drawArmosKnight(knight);
    }

    // Draw rocks
    // Iterate over every active projectile to display it.
    for (const rock of rocks) {
      ctx.fillStyle = '#d0b090';
      ctx.fillRect(Math.floor(rock.x - cameraX), Math.floor(rock.y), rock.size, rock.size);
    }

    // Draw particles
    // Iterate across each particle puff to render the debris cloud.
    for (const p of particles) {
      ctx.fillStyle = 'rgba(255, 220, 160, 0.8)';
      ctx.fillRect(Math.floor(p.x - cameraX), Math.floor(p.y), 2, 2);
    }
  }

  // Run one frame of the raised-view town engine that reuses Link's combat controls but with depth movement.
  function runRaisedTownFrame() {
    // Pull the active spearmen roster for the current plaza unless Link is inside a shop interior.
    const activeSpearmen = townState.inShop ? [] : getTownSpearmen(townState.areaIndex);
    const exitedTown = updateRaisedPlayer();
    // Stop rendering the town when the player just walked back to the overworld.
    if (exitedTown) return;

    updateTownCamera();

    // Update each spearman patrol when outdoors and resolve any collisions against Link.
    if (!townState.inShop) {
      for (const spearman of activeSpearmen) {
        updateTownSpearman(spearman);
        handleTownSpearmanVsPlayer(spearman);
      }
      // Remove defeated spearmen once their poof finishes playing.
      for (let i = activeSpearmen.length - 1; i >= 0; i--) {
        if (activeSpearmen[i].state === 'vanished') {
          activeSpearmen.splice(i, 1);
        }
      }
    }

    updateTownParticles();

    ctx.fillStyle = '#1b1b34';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawTownWorld();
    // Draw the patrolling spearmen before Link so his sprite can overlap them cleanly.
    if (!townState.inShop) {
      for (const spearman of activeSpearmen) {
        drawTownSpearman(spearman);
      }
    }
    drawTownParticles();
    drawPlayer();
  }

  // Main game loop that advances simulation and rendering frames.
  function loop() {
    // Branch between the two engines depending on whether Link is in side-view or overworld mode.
    if (gameMode === GAME_MODE_SIDE_SCROLL) {
      runSideScrollFrame();
    } else if (gameMode === GAME_MODE_OVERWORLD) {
      updateOverworld();
      // Only render the overworld scene when we remain inside that mode after processing movement.
      if (gameMode === GAME_MODE_OVERWORLD) {
        drawOverworld();
      }
    } else {
      runRaisedTownFrame();
    }
    requestAnimationFrame(loop);
  }

  loop();
</script>
</body>
</html>
